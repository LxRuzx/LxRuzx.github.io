<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[HashSet]]></title>
      <url>/HashSet/</url>
      <content type="html"><![CDATA[<p>原文作者：清浅池塘<br>原文地址：<a href="https://zhuanlan.zhihu.com/p/29021276" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/29021276</a></p>
<a id="more"></a>
<p>这篇文章我们先轻松一下，不讲HashMap，来说说HashSet。如果有点Java基础的童鞋，应该都知道List和Set都实现自Collection，List保证元素的添加顺序，元素可重复。而Set不保证元素的添加顺序，元素不可重复</p>
<p><img src="https://pic2.zhimg.com/80/v2-71834e8f9e9581987087113a3ba10abe_hd.jpg" alt=""></p>
<p>先来看看Set家族在Collection中的位置，红框里的内容就是Set的大家族了，Set接口继承自Collection。有两个很重要的实现HashSet和TreeSet。其中黄色部分前面已经说过了是要重点了解的，老规矩，上代码，大家可以先想一想以下代码的执行结果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">  Set&lt;String&gt; strSet = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">  strSet.add(<span class="string">"张三"</span>);</span><br><span class="line">  strSet.add(<span class="string">"李四"</span>);</span><br><span class="line">  strSet.add(<span class="string">"王五"</span>);</span><br><span class="line">  strSet.add(<span class="string">"赵六"</span>);</span><br><span class="line"></span><br><span class="line">  System.out.println(<span class="string">"strSet:"</span> + strSet);</span><br><span class="line">  System.out.println(<span class="string">"strSet.size():"</span> + strSet.size());</span><br><span class="line">  System.out.println(<span class="string">"strSet里是否为空:"</span> + strSet.isEmpty());</span><br><span class="line"></span><br><span class="line">  System.out.println(<span class="string">"删除王五。。。。"</span>);</span><br><span class="line">  <span class="keyword">boolean</span> delFlag = strSet.remove(<span class="string">"王五"</span>);</span><br><span class="line">  System.out.println(<span class="string">"删除王五是否成功"</span> + delFlag);</span><br><span class="line">  System.out.println(<span class="string">"删除王五后的strSet:"</span> + strSet);</span><br><span class="line">  System.out.println(<span class="string">"strSet中是否包含王五:"</span> + strSet.contains(<span class="string">"王五"</span>));</span><br><span class="line">  System.out.println(<span class="string">"strSet中是否包含张三:"</span> + strSet.contains(<span class="string">"张三"</span>));</span><br><span class="line">  </span><br><span class="line">  System.out.println(<span class="string">"clear清除元素..."</span>);</span><br><span class="line">  strSet.clear();</span><br><span class="line">  System.out.println(<span class="string">"clear清除元素后的strSet:"</span> + strSet);</span><br><span class="line">  System.out.println(<span class="string">"strSet长度:"</span> + strSet.size());</span><br><span class="line">  System.out.println(<span class="string">"strSet里是否为空:"</span> + strSet.isEmpty());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先来看第一行代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;String&gt; strSet = <span class="keyword">new</span> HashSet&lt;&gt;();<span class="comment">//new了一个HashSet</span></span><br></pre></td></tr></table></figure>
<p>new了一个HashSet，前面的文章已经说过很多次了，只要是看到new，这货肯定在堆内存里开辟了一块空间，先找到HashSet的构造函数看看，看到如下代码：</p>
<p><img src="https://pic2.zhimg.com/80/v2-be2a9850a450a589de4266b109505e5e_hd.jpg" alt=""></p>
<p>等等，怎么出现了HashMap，这个HashMap到底是什么鬼？再看一下map，追踪一下</p>
<p><img src="https://pic2.zhimg.com/80/v2-cb835a76a4c6ccae48e38a4ba163be93_hd.jpg" alt=""></p>
<p>就是一个HashMap，老规矩画图吧</p>
<p><img src="https://pic4.zhimg.com/80/v2-de878a321bb7b493db636b650c481ebc_hd.jpg" alt=""></p>
<p>HashMap的初始化在<a href="https://zhuanlan.zhihu.com/p/28501879" title="HashMap底层实现原理（上）" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/28501879</a>一文中已经说过了，这里就不再详解了，需要了解的朋友请自行回顾。继续执行以下代码，往strSet添加元素”张三”</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strSet.add(<span class="string">"张三"</span>);</span><br></pre></td></tr></table></figure>
<p>再看add方法</p>
<p><img src="https://pic3.zhimg.com/80/v2-1ce1986255b958d60c4c62cf7c49edab_hd.jpg" alt=""></p>
<p>上面红框里的这行代码和等同于</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> putFlag = map.put(e,PRESENT);</span><br><span class="line"><span class="keyword">return</span> putFlag;</span><br></pre></td></tr></table></figure>
<p>原来就是调用底层HashMap的put方法，把”张三”作为key，PRESENT作为value放在hashMap里，讲HashMap的时候讲过了，如果put时key重了，会返回被覆盖的value值（oldValue），否则返回null，这儿的HashSet又给包装了一下，如果key没有重（oldValue == null），就返回true，否则返回false。继续看这个PRESENT是什么鬼</p>
<p><img src="https://pic4.zhimg.com/80/v2-5d0c711e51209c97caf531af8e3cbe7a_hd.jpg" alt=""></p>
<p>很简单就是new了一个Object，继续画图</p>
<p><img src="https://pic4.zhimg.com/80/v2-3606ff8051091f671369614f16eec973_hd.jpg" alt=""></p>
<p>调用底层HashMap的时候，key是传进去的“张三”，value是PRESENT，也就是一个Object对象，继续往里添加“李四”，“王五”，“赵六”</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">strSet.add(<span class="string">"李四"</span>);</span><br><span class="line">strSet.add(<span class="string">"王五"</span>);</span><br><span class="line">strSet.add(<span class="string">"赵六"</span>);</span><br></pre></td></tr></table></figure>
<p>依次放入“李四”，“王五”，“赵六”，value都是一样的，为PRESENT，继续画图</p>
<p><img src="https://pic3.zhimg.com/80/v2-dfc47fe7f4ead4f33c8e1e4add16904a_hd.jpg" alt=""></p>
<p>所有元素的value都指向Object对象，HashSet虽然底层是用HashMap来实现的，但由于用不到HashMap的value，所以不会为底层HashMap的每个value分配一个内存空间，因此并不会过多的占用内存，请放心使用。</p>
<p>再来看看示例代码里的size()、isEmpty()、remove()、contains()、clear()等方法的实现</p>
<p><img src="http://wx3.sinaimg.cn/mw690/0060lm7Tly1fr68vulpsuj30fb01p3yd.jpg" alt=""></p>
<p>调用的是底层HashMap的size方法</p>
<p><img src="https://pic4.zhimg.com/80/v2-b2cfa61787b95c40dc073737e90327dc_hd.jpg" alt=""></p>
<p>调用的是底层HashMap的isEmpty方法</p>
<p><img src="https://pic4.zhimg.com/80/v2-82194115a67155caf60a8a2377077339_hd.jpg" alt=""></p>
<p>调用的是底层HashMap的remove方法</p>
<p><img src="https://pic4.zhimg.com/80/v2-c110699bfe9464dba0cf027706d6ea3e_hd.jpg" alt=""></p>
<p>调用的是底层HashMap的contains方法</p>
<p><img src="https://pic4.zhimg.com/80/v2-93dffd4fd69c67e1d2a71aedf3724f86_hd.jpg" alt=""></p>
<p>调用的是HashMap的clear方法。</p>
<p><img src="https://pic1.zhimg.com/80/v2-980181946a542c11bacbede8ab37bf6e_hd.jpg" alt=""></p>
<p>构造函数this调了另一个构造函数</p>
<p><img src="https://pic2.zhimg.com/80/v2-3bbe17dc9e1e13a7d6c2cee2fffec1ce_hd.jpg" alt=""></p>
<p>再来看m</p>
<p><img src="https://pic2.zhimg.com/80/v2-3a305981191748de5dc309cde783e870_hd.jpg" alt=""></p>
<p>这个m是NavigableMap类型的，NavigableMap只是一个接口而已</p>
<p><img src="https://pic2.zhimg.com/80/v2-41d6cf5fb96628e482c199250e2ef7e0_hd.jpg" alt=""></p>
<p>再来看TreeMap，实现了NavigableMap这个接口</p>
<p><img src="https://pic3.zhimg.com/80/v2-6f4d3cb4ed1474e0ad56fb2d50d8505d_hd.jpg" alt=""></p>
<p>绕了好大一个圈，其实就是相当于</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NavigableMap m = <span class="keyword">new</span> TreeMap&lt;&gt;();</span><br></pre></td></tr></table></figure>
<p><strong>也就是说，TreeSet底层实现也是利用TreeMap来实现的</strong>，再来看看TreeSet的其它方法</p>
<p><img src="https://pic4.zhimg.com/80/v2-ee415fdf5124011c0157bfb90d60b8f8_hd.jpg" alt=""></p>
<p>调用的是底层TreeMap的size方法</p>
<p><img src="https://pic3.zhimg.com/80/v2-a24eeefe0a5d26b83d5c97bd86e7fff8_hd.jpg" alt=""></p>
<p>调用的是底层TreeMap的isEmpty方法</p>
<p><img src="https://pic4.zhimg.com/80/v2-e0de2f611aff66bbbad3a3ce243b5bc8_hd.jpg" alt=""></p>
<p>TreeMap的add方法是调用底层TreeMap的put方法，只是改了个名字而已</p>
<p>其它方法大致上也是如此，就不一一举例说明了，感兴趣的朋友请自行阅读源码。</p>
<p>最后，执行一下本文开始那段示例代码的执行结果</p>
<p><img src="https://pic4.zhimg.com/80/v2-9a2e3f5f91bae045da599aed754ad233_hd.jpg" alt=""></p>
<p><strong>小结：HashSet底层声明了一个HashMap，HashSet做了一层包装，操作HashSet里的元素时其实是在操作HashMap里的元素。TreeSet底层也是声明了一个TreeMap，操作TreeSet里的元素其实是操作TreeMap里的元素。</strong></p>
<p>有人说<strong>TreeSet和LinkedHashSet是有序的</strong>，这里强调一下，我们指的<strong>Set不保证插入有序是指Set这个接口的规范，实现类只要遵循这个规范即可</strong>，当然也可以写有序的版本出来，<strong>比如LinkedHashSet。而TreeSet是里面的内容有序（按照一定规则排序），但不是指元素的添加顺序。</strong></p>
<blockquote>
<p>注意：大家在写TreeSet测试本文代码的时候，可能刚好得到张三，李四，王五、赵六这样的顺序，这是碰巧，请大家打乱顺序测试。</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> Java基础 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Why String is immutable in Java]]></title>
      <url>/Why%20String%20is%20immutable%20in%20Java/</url>
      <content type="html"><![CDATA[<h2 id="because…"><a href="#because…" class="headerlink" title="because…"></a>because…</h2><a id="more"></a>
<p>String is immutable in Java. An immutable class is simply a class whose instances cannot be modified. All information in an instance is initialized when the instance is created and the information can not be modified. There are many advantages of immutable classes. This article summarizes why String is designed to be immutable. This post illustrate the immutability concept in the perspective of memory, synchronization and data structures.</p>
<h2 id="Requirement-of-String-Pool"><a href="#Requirement-of-String-Pool" class="headerlink" title="Requirement of String Pool"></a>Requirement of String Pool</h2><p>String pool (String intern pool) is a special storage area in Method Area. When a string is created and if the string already exists in the pool, the reference of the existing string will be returned, instead of creating a new object.</p>
<p>The following code will create only one string object in the heap.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> String string1 = <span class="string">"abcd"</span>;</span><br><span class="line">String string2 = <span class="string">"abcd"</span>;</span><br></pre></td></tr></table></figure>
<p>Here is how it looks:<br>java-string-pool</p>
<p>If a string is mutable, changing the string with one reference will lead to the wrong value for the other references.</p>
<h2 id="Caching-Hashcode"><a href="#Caching-Hashcode" class="headerlink" title="Caching Hashcode"></a>Caching Hashcode</h2><p>The hashcode of a string is frequently used in Java. For example, in a HashMap or HashSet. Being immutable guarantees that hashcode will always be the same so that it can be cashed without worrying about the changes.That means, there is no need to calculate hashcode every time it is used. This is more efficient.</p>
<p>In String class, it has the following code:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> hash;<span class="comment">//this is used to cache hash code.</span></span><br></pre></td></tr></table></figure>
<h2 id="Facilitating-the-Use-of-Other-Objects"><a href="#Facilitating-the-Use-of-Other-Objects" class="headerlink" title="Facilitating the Use of Other Objects"></a>Facilitating the Use of Other Objects</h2><p>To make this concrete, consider the following program:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">HashSet&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">set.add(<span class="keyword">new</span> String(<span class="string">"a"</span>));</span><br><span class="line">set.add(<span class="keyword">new</span> String(<span class="string">"b"</span>));</span><br><span class="line">set.add(<span class="keyword">new</span> String(<span class="string">"c"</span>));</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span>(String a: set)</span><br><span class="line">	a.value = <span class="string">"a"</span>;</span><br></pre></td></tr></table></figure>
<p>In this example, if String is mutable, its value can be changed which would violate the design of set (set contains unduplicated elements). Of curse, the example above is just for demonstration purpose and there is no value field in a real string class.</p>
<h2 id="Security"><a href="#Security" class="headerlink" title="Security"></a>Security</h2><p>String is widely used as a parameter for many java classes, e.g. network connection, opening files, etc. Were String not immutable, a connection or file would be changed and this can lead to a serious security threat. The method thought it was connecting to one machine, but was not. Mutable strings could cause a security problem in Reflection too, as the parameters are strings.</p>
<p>Here is a code example:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">connect</span><span class="params">(string s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isSecure(s)) &#123; </span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(); </span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//here will cause problem, if s is changed before this by using other references.    </span></span><br><span class="line">    causeProblem(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Immutable-objects-are-naturally-thread-safe"><a href="#Immutable-objects-are-naturally-thread-safe" class="headerlink" title="Immutable objects are naturally thread-safe"></a>Immutable objects are naturally thread-safe</h2><p>Because immutable objects can not be changed, they can be shared among multiple threads freely. This eliminates the requirements of doing synchronization.</p>
<p>In summary, String is designed to be immutable for efficiency and security reasons. This is also the reason why immutable classes are preferred in many cases in general.</p>
<p><strong>注：本文摘自：<a href="https://www.programcreek.com/2013/04/why-string-is-immutable-in-java/" target="_blank" rel="noopener">https://www.programcreek.com/2013/04/why-string-is-immutable-in-java/</a></strong></p>
]]></content>
      
        <categories>
            
            <category> Java基础 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Abstract and Interface]]></title>
      <url>/Abstract-and-Interface/</url>
      <content type="html"><![CDATA[<h2 id="抽象类与接口"><a href="#抽象类与接口" class="headerlink" title="抽象类与接口"></a>抽象类与接口</h2><a id="more"></a>
<h3 id="一-抽象类"><a href="#一-抽象类" class="headerlink" title="一.抽象类"></a>一.抽象类</h3><p>抽象方法必须用abstract关键字进行修饰。如果一个类含有抽象方法，则称这个类为抽象类，抽象类必须在类前用abstract关键字修饰。因为抽象类中含有无具体实现的方法，所以不能用抽象类创建对象。</p>
<p>将抽象类定义为“包含抽象方法的类”但是如果一个类不包含抽象方法，只用abstract修饰的话也是抽象类，也就是说抽象类不一定必须要含有抽象方法。<br>问题是  如果一个抽象类不包含抽象方法那又为何需要抽象类呢</p>
<p>包含抽象方法的类称为抽象类，但并不意味着抽象类中只能有抽象方法，它和普通类一样，同样可以拥有成员变量和普通的成员方法。注意，抽象类和普通类的主要有三点区别：<br>1.抽象方法必须为public或者protected（因为如果为private，则不能被子类继承，子类便无法实现该方法），缺省情况下默认为public。<br>2.抽象类不能用来创建对象；<br>3.如果一个类继承于一个抽象类，则子类必须实现父类的抽象方法。如果子类没有实现父类的抽象方法，则必须将子类也定义为为abstract类。<br>在其他方面，抽象类和普通的类并没有区别。</p>
<h3 id="二-接口"><a href="#二-接口" class="headerlink" title="二.接口"></a>二.接口</h3><p>接口，英文称作interface，在软件工程中，接口泛指供别人调用的方法或者函数。从这里，我们可以体会到Java语言设计者的初衷，它是对行为的抽象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">public</span>] <span class="class"><span class="keyword">interface</span> <span class="title">InterfaceName</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接口可以含有变量和方法<br>注意：<br>接口中的变量会被隐式指向public static final变量(只能是public static final 用         private修饰会报编译错误)。<br>接口中的方法会被隐式指定为public abstract方法且只能是public abstract方法（用其他关键字，比如private、protected、static、 final等修饰会报编译错误）<br>接口中所有的方法不能有具体的实现，也就是说，接口中的方法必须都是抽象方法<br>从这里可以隐约看出接口和抽象类的区别，接口是一种极度抽象的类型，它比抽象类更加“抽象”，并且一般情况下不在接口中定义变量。</p>
<p>要让一个类遵循某组特地的接口需要使用implements关键字，具体格式如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class ClassName implements Interface1,Interface2,[....]&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看出，允许一个类遵循多个特定的接口。如果一个非抽象类遵循了某个接口，就必须实现该接口中的所有方法。对于遵循某个接口的抽象类，可以不实现该接口中的抽象方法。</p>
<h3 id="三、抽象类和接口的区别"><a href="#三、抽象类和接口的区别" class="headerlink" title="三、抽象类和接口的区别"></a>三、抽象类和接口的区别</h3><p>1.语法层面上的区别</p>
<pre><code>1.抽象类可以提供成员方法的实现细节，而接口中只能存在public abstract 方法；

2.抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是public static final类型的；

3.抽象类可以有静态代码块和静态方法； 接口中不能含有静态代码块以及静态方法

4.一个类只能继承一个抽象类，而一个类却可以实现多个接口。
</code></pre><p>2.设计层面上的区别</p>
<pre><code>1.抽象类是对一种事物的抽象，抽象类是对整个类整体进行抽象，包括属性、行为

2.接口是对行为的抽象，接口是对类（局部）进行抽象
</code></pre><p>举个例子：<br>    飞机和鸟是不同类的事物，但是它们有一个共性，就是都会飞行，那么在设计的时候可以将飞机设计为一个类Airplane，将鸟设计为一个类Bird，但是不能将 飞行 这个特性也设计为类，因此它只是一个行为特性，并不是对一类事物的抽象描述。此时可以将 飞行 设计为一个接口Fly，包含方法fly( )，然后Airplane和Bird分别根据自己的需要实现Fly这个接口。然后至于有不同种类的飞机，比如战斗机、民用飞机等直接继承Airplane即可，对于鸟也是类似的，不同种类的鸟直接继承Bird类即可。从这里可以看出，继承是一个 “是不是”的关系，而 接口 实现则是 “有没有”的关系。如果一个类继承了某个抽象类，则子类必定是抽象类的种类，而接口实现则是有没有、具备不具备的关系，比如鸟是否能飞（或者是否具备飞行这个特点），能飞行则可以实现这个接口，不能飞行就不实现这个接口。</p>
<p>3.设计层面不同<br>    抽象类作为很多子类的父类，它是一种模板式设计。而接口是一种行为规范，它是一种辐射式设计。什么是模板式设计？最简单例子，大家都用过ppt里面的模板，如果用模板A设计了ppt B和ppt C，ppt B和ppt C公共的部分就是模板A了，如果它们的公共部分需要改动，则只需要改动模板A就可以了，不需要重新对ppt B和ppt C进行改动。而辐射式设计，比如某个电梯都装了某种报警器，一旦要更新报警器，就必须全部更新。也就是说对于抽象类，如果需要添加新的方法，可以直接在抽象类中添加具体的实现，子类可以不进行变更；而对于接口则不行，如果接口进行了变更，则所有实现这个接口的类都必须进行相应的改动。</p>
]]></content>
      
        <categories>
            
            <category> Java基础 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[spring-boot+mybatis]]></title>
      <url>/spring-boot%E9%9B%86%E6%88%90mybatis/</url>
      <content type="html"><![CDATA[<h2 id="整合mybatis"><a href="#整合mybatis" class="headerlink" title="整合mybatis"></a>整合mybatis</h2><a id="more"></a>
<h2 id="pom-xml依赖"><a href="#pom-xml依赖" class="headerlink" title="pom.xml依赖"></a>pom.xml依赖</h2><ul>
<li>引入连接mysql的必要依赖mysql-connector-java</li>
<li>引入整合MyBatis的核心依赖mybatis-spring-boot-starter</li>
<li>这里不引入spring-boot-starter-jdbc依赖，是由于mybatis-spring-boot-starter中已经包含了此依赖</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">	</span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">mybatis-spring-boot</span>&gt;</span>1.2.0<span class="tag">&lt;/<span class="name">mybatis-spring-boot</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">&lt;!-- Spring Boot Web 依赖 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">&lt;!-- Spring Boot Test 依赖 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">&lt;!-- Spring Boot Mybatis 依赖 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;mybatis-spring-boot&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="项目配置"><a href="#项目配置" class="headerlink" title="项目配置"></a>项目配置</h3><blockquote>
<p>修改resource下的application.properties</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 数据源配置</span><br><span class="line">spring.datasource.url=jdbc:mysql://localhost:3306/test?useUnicode=true&amp;characterEncoding=utf8</span><br><span class="line">spring.datasource.username=root</span><br><span class="line">spring.datasource.password=root</span><br><span class="line">spring.datasource.driver-class-name=com.mysql.jdbc.Driver</span><br><span class="line"></span><br><span class="line">## Mybatis 配置</span><br><span class="line">mybatis.typeAliasesPackage=org.spring.springboot.domain</span><br><span class="line">mybatis.mapperLocations=classpath:mapper/*.xml</span><br></pre></td></tr></table></figure>
<h2 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h2><p><img src="https://s1.ax1x.com/2018/03/24/9qAmE6.png" alt=""></p>
<h2 id="使用Mybatis"><a href="#使用Mybatis" class="headerlink" title="使用Mybatis"></a>使用Mybatis</h2><p>在MySQL中创建City表，并在src/domain/下创建City实体类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">City</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long provinceId;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String cityName;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> String description;</span><br><span class="line">    <span class="comment">// 省略getter和setter</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在resource中创建mapper文件夹，在mapper文件夹下创建CityMapper.xml</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span><br><span class="line"><span class="meta">&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd" &gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"org.spring.springboot.dao.CityDao"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"BaseResultMap"</span> <span class="attr">type</span>=<span class="string">"org.spring.springboot.domain.City"</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"id"</span> <span class="attr">property</span>=<span class="string">"id"</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"province_id"</span> <span class="attr">property</span>=<span class="string">"provinceId"</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"city_name"</span> <span class="attr">property</span>=<span class="string">"cityName"</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"description"</span> <span class="attr">property</span>=<span class="string">"description"</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">parameterMap</span> <span class="attr">id</span>=<span class="string">"City"</span> <span class="attr">type</span>=<span class="string">"org.spring.springboot.domain.City"</span>/&gt;</span></span><br><span class="line">	</span><br><span class="line">	<span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">"Base_Column_List"</span>&gt;</span></span><br><span class="line">		id, province_id, city_name, description</span><br><span class="line">	<span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br><span class="line">	</span><br><span class="line">	<span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findByName"</span> <span class="attr">resultMap</span>=<span class="string">"BaseResultMap"</span> <span class="attr">parameterType</span>=<span class="string">"java.lang.String"</span>&gt;</span></span><br><span class="line">		select</span><br><span class="line">		<span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">"Base_Column_List"</span> /&gt;</span></span><br><span class="line">		from city</span><br><span class="line">		where city_name = #&#123;cityName&#125;</span><br><span class="line">	<span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">	</span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="Controller层"><a href="#Controller层" class="headerlink" title="Controller层"></a>Controller层</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CityRestController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> CityService cityService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/api/city"</span>, method = RequestMethod.GET)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> City <span class="title">findOneCity</span><span class="params">(@RequestParam(value = <span class="string">"cityName"</span>, required = <span class="keyword">true</span>)</span> String cityName) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cityService.findCityByName(cityName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Service层"><a href="#Service层" class="headerlink" title="Service层"></a>Service层</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 城市业务逻辑接口类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CityService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据城市名称，查询城市信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cityName</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">City <span class="title">findCityByName</span><span class="params">(String cityName)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 城市业务逻辑实现类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CityServiceImpl</span> <span class="keyword">implements</span> <span class="title">CityService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> CityDao cityDao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> City <span class="title">findCityByName</span><span class="params">(String cityName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cityDao.findByName(cityName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Dao层"><a href="#Dao层" class="headerlink" title="Dao层"></a>Dao层</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 城市 DAO 接口类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CityDao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据城市名称，查询城市信息</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cityName 城市名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">City <span class="title">findByName</span><span class="params">(@Param(<span class="string">"cityName"</span>)</span> String cityName)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> spring-boot~ </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[记第一次爬虫]]></title>
      <url>/web%20crawler/</url>
      <content type="html"><![CDATA[<p>爬取姓名网的所有姓和名</p>
<a id="more"></a>
<p>pom.xml</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.it<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>demo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>war<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>demo Maven Webapp<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.apache.org<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.8.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.34<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.16.16<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.jsoup<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jsoup<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.9.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.httpcomponents<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>httpcore<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.4.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-beans<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.3.9.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-collections<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-collections<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-lang3<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.jfinal<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jfinal<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.26<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.34<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.belerweb<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pinyin4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">finalName</span>&gt;</span>demo<span class="tag">&lt;/<span class="name">finalName</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>获得所有姓以及姓氏的链接</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> namekit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.druid.filter.stat.StatFilter;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.druid.util.JdbcConstants;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.druid.wall.WallFilter;</span><br><span class="line"><span class="keyword">import</span> com.jfinal.plugin.activerecord.ActiveRecordPlugin;</span><br><span class="line"><span class="keyword">import</span> com.jfinal.plugin.activerecord.Db;</span><br><span class="line"><span class="keyword">import</span> com.jfinal.plugin.activerecord.Record;</span><br><span class="line"><span class="keyword">import</span> com.jfinal.plugin.druid.DruidPlugin;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.regexp.internal.RE;</span><br><span class="line"><span class="keyword">import</span> http.HttpConfigs;</span><br><span class="line"><span class="keyword">import</span> http.HttpKit;</span><br><span class="line"><span class="keyword">import</span> http.HttpResult;</span><br><span class="line"><span class="keyword">import</span> org.jsoup.nodes.Element;</span><br><span class="line"><span class="keyword">import</span> org.jsoup.select.Elements;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by LxRuzx on 2017.12.5.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NameDemo2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        HttpResult hr = HttpKit.get(<span class="string">"http://www.yw11.com/namelist.php"</span>, <span class="keyword">new</span> HttpConfigs());</span><br><span class="line">        Elements lis = hr.getDoc().select(<span class="string">".e3"</span>).select(<span class="string">"a"</span>);</span><br><span class="line">        <span class="keyword">for</span> (Element li : lis) &#123;</span><br><span class="line">            String href = li.attr(<span class="string">"href"</span>);</span><br><span class="line">            System.out.println(href);</span><br><span class="line">            System.out.println(li.text());</span><br><span class="line">            Db.save(<span class="string">"lname"</span>,<span class="keyword">new</span> Record().set(<span class="string">"Lname"</span>,li.text()).set(<span class="string">"url"</span>,href));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        DruidPlugin druidPlugin = createDruidPlugin();</span><br><span class="line">        druidPlugin.start();</span><br><span class="line">        ActiveRecordPlugin activeRecordPlugin = <span class="keyword">new</span> ActiveRecordPlugin(druidPlugin);</span><br><span class="line">        activeRecordPlugin.setShowSql(<span class="keyword">true</span>);</span><br><span class="line">        activeRecordPlugin.setDevMode(<span class="keyword">true</span>);</span><br><span class="line">        activeRecordPlugin.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> DruidPlugin <span class="title">createDruidPlugin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String jdbcUrl = <span class="string">"jdbc:mysql://localhost:3306/asd"</span></span><br><span class="line">                + <span class="string">"?useUnicode=true&amp;characterEncoding=utf8&amp;zeroDateTimeBehavior=convertToNull"</span>;</span><br><span class="line">        DruidPlugin druidPlugin = <span class="keyword">new</span> DruidPlugin(jdbcUrl, <span class="string">"root"</span>, <span class="string">"root"</span>);</span><br><span class="line">        StatFilter stat = <span class="keyword">new</span> StatFilter();</span><br><span class="line">        stat.setMergeSql(<span class="keyword">true</span>);</span><br><span class="line">        druidPlugin.addFilter(stat);</span><br><span class="line"></span><br><span class="line">        WallFilter wall = <span class="keyword">new</span> WallFilter();</span><br><span class="line">        wall.setDbType(JdbcConstants.MYSQL);</span><br><span class="line">        druidPlugin.addFilter(wall);</span><br><span class="line">        <span class="keyword">return</span> druidPlugin;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如下所示：</p>
<p>/html/mi/3-9-0-1.htm<br>李<br>/html/mi/3-5-0-1.htm<br>王<br>/html/mi/3-21-0-1.htm<br>张<br>/html/mi/3-27-0-1.htm<br>刘</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> namekit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.druid.filter.stat.StatFilter;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.druid.util.JdbcConstants;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.druid.wall.WallFilter;</span><br><span class="line"><span class="keyword">import</span> com.jfinal.kit.PropKit;</span><br><span class="line"><span class="keyword">import</span> com.jfinal.plugin.activerecord.ActiveRecordPlugin;</span><br><span class="line"><span class="keyword">import</span> com.jfinal.plugin.activerecord.Db;</span><br><span class="line"><span class="keyword">import</span> com.jfinal.plugin.activerecord.Record;</span><br><span class="line"><span class="keyword">import</span> com.jfinal.plugin.druid.DruidPlugin;</span><br><span class="line"><span class="keyword">import</span> http.HttpConfigs;</span><br><span class="line"><span class="keyword">import</span> http.HttpKit;</span><br><span class="line"><span class="keyword">import</span> http.HttpResult;</span><br><span class="line"><span class="keyword">import</span> org.jsoup.Jsoup;</span><br><span class="line"><span class="keyword">import</span> org.jsoup.nodes.Document;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.jsoup.nodes.Element;</span><br><span class="line"><span class="keyword">import</span> org.jsoup.select.Elements;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by LxRuzx on 2017.12.5.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NameDemo1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        init();</span><br><span class="line">        List&lt;Record&gt; list = Db.find(<span class="string">"select * from fname "</span>);</span><br><span class="line">        <span class="keyword">for</span> (Record rec : list) &#123;</span><br><span class="line">            <span class="comment">//根据获取的链接 拼接url</span></span><br><span class="line">            HttpResult hr = HttpKit.get(<span class="string">"http://www.yw11.com"</span> + rec.getStr(<span class="string">"url"</span>), <span class="keyword">new</span> HttpConfigs());</span><br><span class="line">            Elements lis = hr.getDoc().select(<span class="string">".listbox1_text"</span>).select(<span class="string">"li"</span>);</span><br><span class="line">            PinYinKit pinYinKit = <span class="keyword">new</span> PinYinKit();</span><br><span class="line">            <span class="keyword">for</span> (Element li : lis) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    String substring = li.text().substring(<span class="number">1</span>);</span><br><span class="line">                    String pingYin = pinYinKit.getPingYin(substring);</span><br><span class="line">                    String pinYinHeadChar = pinYinKit.getPinYinHeadChar(substring);</span><br><span class="line">                    <span class="comment">//向数据库保存 名字 拼音 拼音缩写</span></span><br><span class="line">                    Record set = <span class="keyword">new</span> Record().set(<span class="string">"Lname"</span>, substring).set(<span class="string">"PinYin"</span>, pingYin).set(<span class="string">"PinYinHandChar"</span>, pinYinHeadChar);</span><br><span class="line">                    Db.save(<span class="string">"lname"</span>, set);</span><br><span class="line">		<span class="comment">//如果遇到相同的，跳过就行。</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        DruidPlugin druidPlugin = createDruidPlugin();</span><br><span class="line">        druidPlugin.start();</span><br><span class="line">        ActiveRecordPlugin activeRecordPlugin = <span class="keyword">new</span> ActiveRecordPlugin(druidPlugin);</span><br><span class="line">        activeRecordPlugin.setShowSql(<span class="keyword">true</span>);</span><br><span class="line">        activeRecordPlugin.setDevMode(<span class="keyword">true</span>);</span><br><span class="line">        activeRecordPlugin.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> DruidPlugin <span class="title">createDruidPlugin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String jdbcUrl = <span class="string">"jdbc:mysql://localhost:3306/asd"</span></span><br><span class="line">                + <span class="string">"?useUnicode=true&amp;characterEncoding=utf8&amp;zeroDateTimeBehavior=convertToNull"</span>;</span><br><span class="line">        DruidPlugin druidPlugin = <span class="keyword">new</span> DruidPlugin(jdbcUrl, <span class="string">"root"</span>, <span class="string">"root"</span>);</span><br><span class="line">        StatFilter stat = <span class="keyword">new</span> StatFilter();</span><br><span class="line">        stat.setMergeSql(<span class="keyword">true</span>);</span><br><span class="line">        druidPlugin.addFilter(stat);</span><br><span class="line"></span><br><span class="line">        WallFilter wall = <span class="keyword">new</span> WallFilter();</span><br><span class="line">        wall.setDbType(JdbcConstants.MYSQL);</span><br><span class="line">        druidPlugin.addFilter(wall);</span><br><span class="line">        <span class="keyword">return</span> druidPlugin;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://s1.ax1x.com/2017/12/07/TZFOO.png" alt="TZFOO.png"><br>ok！</p>
]]></content>
      
        <categories>
            
            <category> 爬虫~ </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[spring-boot~HelloWorld]]></title>
      <url>/spring-boot-first/</url>
      <content type="html"><![CDATA[<h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><blockquote>
<p>使用Spring Boot。<br>你可以像使用标准的Java库文件一样使用Spring Boot。简单的将需要的 spring-boot-*.jar 添加到classpath即可。<br>Spring Boot不要求任何特殊的工具集成，所以可以使用任何IDE，甚至文本编辑器。</p>
</blockquote>
<a id="more"></a>
<blockquote>
<p>只是，仍然建议使用build工具：Maven 或 Gradle。</p>
<p>Spring Boot依赖 使用 org.springframework.boot groupId 。通常，让你的Maven POM文件继承 spring-boot-starter-parent，并声明一个或多个 Starter POMs依赖即可。Spring Boot也提供了一个可选的 Maven Plugin来创建可执行的jars。如下：</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.example<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>myproject<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- Inherit defaults from Spring Boot --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- Add typical dependencies for a web application --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- Package as an executable jar --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>需要注意的是， spring-boot-starter-parent 是一个非常好的方法，但并不适用于所有情况。有时你需要继承其他的POM，或者你不喜欢默认的设置。</p>
</blockquote>
<h2 id="不继承spring-boot-starter-parent："><a href="#不继承spring-boot-starter-parent：" class="headerlink" title="不继承spring-boot-starter-parent："></a>不继承spring-boot-starter-parent：</h2><blockquote>
<p>这种情况下，仍然可以使用dependency management，但不能使用plugin management啦。方式如下：</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5.1.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意，scope是 import 。而且，这种情况下，不再允许在&lt; properties &gt;覆盖相应的版本。如果要使用其他版本，需要在上面的前面添加一个完整的dependency。如下：</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.data<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-data-releasetrain<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>Kay-SR7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5.1.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>另外，Spring Boot还提供了一个Maven Plugin：spring-boot-maven-plugin，用于将项目打包成fat jar（executable jar）。<br>继承时只需要声明一下即可使用：</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>Maven构建项目</p>
<ol>
<li>File -&gt; New Project<br><img src="http://wx4.sinaimg.cn/mw690/0060lm7Tly1frbtev7k7dj30mr0fb0ua.jpg" alt=""></li>
<li>Next<br><img src="http://wx4.sinaimg.cn/mw690/0060lm7Tly1frbthawt1lj30mr0fb0ua.jpg" alt=""></li>
<li>你可以在这里选择自己需要的，在生成最终的项目时会自动加入到maven中。<br><img src="http://wx2.sinaimg.cn/mw690/0060lm7Tly1frbtm3wk1kj30ml0ffwgh.jpg" alt=""></li>
<li>然后Finish生成<br><img src="https://s1.ax1x.com/2017/12/05/oZ5sU.png" alt="oZ5sU.png"></li>
</ol>
<p>如上图所示，Spring Boot的基础结构共三个文件:</p>
<ul>
<li><p>src/main/java  程序开发以及主程序入口</p>
</li>
<li><p>src/main/resources 配置文件</p>
</li>
<li><p>src/test/java  测试程序</p>
</li>
</ul>
<p>另外，spingboot建议的目录结果如下：</p>
<p>root package结构：com.example.myproject</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">com</span><br><span class="line">  +- example</span><br><span class="line">	+- myproject</span><br><span class="line">  +- Application.java</span><br><span class="line">  |</span><br><span class="line">  +- domain</span><br><span class="line">  |  +- Customer.java</span><br><span class="line">  |  +- CustomerRepository.java</span><br><span class="line">  |</span><br><span class="line">  +- service</span><br><span class="line">  |  +- CustomerService.java</span><br><span class="line">  |</span><br><span class="line">  +- controller</span><br><span class="line">  |  +- CustomerController.java</span><br><span class="line">  |</span><br></pre></td></tr></table></figure>
<p>1、Application.java 建议放到跟目录下面,主要用于做一些框架配置</p>
<p>2、domain目录主要用于实体（Entity）与数据访问层（Repository）</p>
<p>3、service 层主要是业务类代码</p>
<p>4、controller 负责页面访问控制</p>
<p>采用默认配置可以省去很多配置，当然也可以根据自己的喜欢来进行更改</p>
<p>最后，启动Application main方法，至此一个java项目搭建好了！</p>
<h2 id="引入web模块"><a href="#引入web模块" class="headerlink" title="引入web模块"></a>引入web模块</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>1.pom.xml文件中默认有两个模块：</p>
<p>spring-boot-starter：核心模块，包括自动配置支持、日志和YAML；</p>
<p>spring-boot-starter-test：测试模块，包括JUnit、Hamcrest、Mockito。</p>
<p>2.编写Controller内容</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/hello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">index</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello World"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>@RestController的意思就是controller里面的方法都以json格式输出，不用再写什么jackjson配置的了！<br>如果需要使用页面开发只要使用@Controller即可。</p>
<p>3、启动主程序，打开浏览器localhost8080/hello就可以看到效果了。</p>
<h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h2><p>打开的src/test/下的测试入口，编写简单的http请求来测试；使用mockmvc进行，利用MockMvcResultHandlers.print()打印出执行结果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldControlerTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MockMvc mvc;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        mvc = MockMvcBuilders.standaloneSetup(<span class="keyword">new</span> HelloWorldController()).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getHello</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    mvc.perform(MockMvcRequestBuilders.get(<span class="string">"/hello"</span>).accept(MediaType.APPLICATION_JSON))</span><br><span class="line">                .andExpect(MockMvcResultMatchers.status().isOk())</span><br><span class="line">                .andDo(MockMvcResultHandlers.print())</span><br><span class="line">                .andReturn();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>开发环境测试</p>
<p>热启动：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	     加入以下代码即可，不用再写一个</span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">fork</span>&gt;</span>true<span class="tag">&lt;/<span class="name">fork</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>@SpringBootApplication<br>@SpringBootApplication 等同于默认的属性的 @Configuration, @EnableAutoConfiguration and @ComponentScan。<br>注意:@ComponentScan 不能凭空使用。</p>
<p>@RestController 解析Json数据 相当于@Controller+@ResponseBody<br>注意：这是MVC中的注解，并不是boot中的。</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> spring-boot~ </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[HashMap底层实现原理]]></title>
      <url>/HashMap/</url>
      <content type="html"><![CDATA[<h2 id="HashMap基于Map接口的实现"><a href="#HashMap基于Map接口的实现" class="headerlink" title="HashMap基于Map接口的实现"></a>HashMap基于Map接口的实现</h2><blockquote>
<p>采用哈希表的结构存储键值对，它允许null键/值(键只能有且只有一个null)，底层是数组，线程不安全，非同步，不保证插入有序(比如插入的顺序)，也不保证序不随时间变化，HashMap存储这Entry(hash,key,value,next)对象。</p>
</blockquote>
<a id="more"></a>
<p>Map就是一个key，对应一个value。话不多说，上代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Map&lt;String, Person&gt; hm = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    hm.put(<span class="string">"张三"</span>, <span class="keyword">new</span> Person(<span class="string">"张三"</span>, <span class="number">21</span>));</span><br><span class="line">    hm.put(<span class="string">"李四"</span>, <span class="keyword">new</span> Person(<span class="string">"李四"</span>, <span class="number">19</span>));</span><br><span class="line">    hm.put(<span class="string">"王五"</span>, <span class="keyword">new</span> Person(<span class="string">"王五"</span>, <span class="number">25</span>));</span><br><span class="line">    hm.put(<span class="string">"赵六"</span>, <span class="keyword">new</span> Person(<span class="string">"赵六"</span>, <span class="number">24</span>));</span><br><span class="line">    hm.put(<span class="string">"孙七"</span>, <span class="keyword">new</span> Person(<span class="string">"孙七"</span>, <span class="number">32</span>));</span><br><span class="line">    hm.put(<span class="string">"周八"</span>, <span class="keyword">new</span> Person(<span class="string">"周八"</span>, <span class="number">17</span>));</span><br><span class="line">    hm.put(<span class="string">"钱九"</span>, <span class="keyword">new</span> Person(<span class="string">"钱九"</span>, <span class="number">24</span>));</span><br><span class="line">    hm.put(<span class="string">"吴十"</span>, <span class="keyword">new</span> Person(<span class="string">"吴十"</span>, <span class="number">23</span>));</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行构造函数，当看到这个new，第一反应就是它在堆内存开辟一块空间<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String,String&gt; hs = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br></pre></td></tr></table></figure></p>
<p>构造函数如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all other fields defaulted</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>初始化了一个负载因子<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br></pre></td></tr></table></figure></p>
<p>bucket数组</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br></pre></td></tr></table></figure>
<p>接着来看看这个数组里都有些什么</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">   <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">   <span class="keyword">final</span> K key;      <span class="comment">//key value 是用来存放put的key，value值</span></span><br><span class="line">   V value;</span><br><span class="line">   Node&lt;K,V&gt; next;   <span class="comment">//next 是用来标记下一个元素</span></span><br><span class="line"><span class="comment">//构造函数</span></span><br><span class="line">   Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">       <span class="keyword">this</span>.hash = hash;</span><br><span class="line">       <span class="keyword">this</span>.key = key;     </span><br><span class="line">       <span class="keyword">this</span>.value = value;  </span><br><span class="line">       <span class="keyword">this</span>.next = next;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>key、value用来保存我们往Map里放入的数据，next用来标记Node节点的下一个元素。</p>
<p>先从成员变量入手</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * The number of times this HashMap has been structurally modified</span></span><br><span class="line"><span class="comment">    * Structural modifications are those that change the number of mappings in</span></span><br><span class="line"><span class="comment">    * the HashMap or otherwise modify its internal structure (e.g.,</span></span><br><span class="line"><span class="comment">    * rehash).  This field is used to make iterators on Collection-views of</span></span><br><span class="line"><span class="comment">    * the HashMap fail-fast.  (See ConcurrentModificationException).</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br></pre></td></tr></table></figure>
<p>一个是逻辑长度，一个是修改次数，ArrayList、LinkedList中也有这两个属性。</p>
<p><img src="https://s1.ax1x.com/2017/11/30/4AWtK.jpg" alt=""><br>这是初始化完的效果，成员变量table数组默认为null，size默认为0，负载因子默认为0.75f，初始化完成，往里添加元素，来看一下put源码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 对key的hashCode()做hash</span></span><br><span class="line">      <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>就一行代码，调用了putVal方法，其中key是传进来的“张三”这个字符串对象，value是“张三”这个Person对象，调用了一个方法hash()，再看一下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> h;</span><br><span class="line">	<span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看到了hashCode方法，强调一点，如果重写equals方法的时候，一定要重写hashCode方法，因为key是基于hashCode来处理的，继续看putVal方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">       Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">	<span class="comment">//放入第一个元素时table为空，触发resize方法</span></span><br><span class="line">       <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>) </span><br><span class="line">           n = (tab = resize()).length;     </span><br><span class="line">	 <span class="comment">//计算hash对应的位置，并对null做处理</span></span><br><span class="line">       <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">           tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">       <span class="keyword">else</span> &#123;</span><br><span class="line">           Node&lt;K,V&gt; e; K k;</span><br><span class="line">		<span class="comment">//如果节点已经存在就替换old value</span></span><br><span class="line">           <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">               ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">               e = p;</span><br><span class="line">		 <span class="comment">//bucket中是树</span></span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">               e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">		<span class="comment">//bucket中是链表</span></span><br><span class="line">           <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                   <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                       p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">			<span class="comment">//链表长度达到设定的转换为红黑树的阈值</span></span><br><span class="line">                       <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">			<span class="comment">/** 注意：这个方法并不是直接将链表转换为红黑树，</span></span><br><span class="line"><span class="comment">			 *  如果当前buckets长度小于64，则扩容，否则将链表转换为红黑树</span></span><br><span class="line"><span class="comment">			 */</span> </span><br><span class="line">                           treeifyBin(tab, hash);</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                       ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">                   p = e;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">		<span class="comment">//写入</span></span><br><span class="line">           <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">               V oldValue = e.value;</span><br><span class="line">               <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                   e.value = value;</span><br><span class="line">               afterNodeAccess(e);</span><br><span class="line">               <span class="keyword">return</span> oldValue;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       ++modCount;</span><br><span class="line">	<span class="comment">//当前容量超出 loadfactor*current capacity，则扩容 resize()</span></span><br><span class="line">       <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">           resize();</span><br><span class="line">       afterNodeInsertion(evict);</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>当放入第一个元素时，会触发resize方法的以下关键代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">newCap = DEFAULT_INITIAL_CAPACITY;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br></pre></td></tr></table></figure>
<p>就是移位运算符，1 &lt;&lt; 4相当于16。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br></pre></td></tr></table></figure>
<p>这句是关键，当我们放入第一个元素时，如果底层数组还是null，系统会初始化一个长度为16的Node数组，和ArrayList初始化很像。</p>
<p>在resize方法的最后一步return newTab。返回new出来的数组，接着看图，下图中会省略部分数组内容，注意：虽然数组长度为16，但逻辑长度size依然为0。</p>
<p><img src="https://s1.ax1x.com/2017/11/30/4ELr9.jpg" alt=""></p>
<p>继续执行putval方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">          tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure>
<p>我们把它拆分开来，便于理解。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">i = (n - <span class="number">1</span>) &amp; hash;<span class="comment">//hash是传过来的，其中n是底层数组的长度，用&amp;运算符计算出i的值 </span></span><br><span class="line">p = tab[i];<span class="comment">//用计算出来的i的值作为下标从数组中元素</span></span><br><span class="line"><span class="keyword">if</span>(p == <span class="keyword">null</span>)&#123;<span class="comment">//如果这个元素为null，用key,value构造一个Node对象放入数组下标为i的位置</span></span><br><span class="line">     tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个hash是字符串”张三”这个对象的hashCode方法与HashMap提供的hash()方法共同计算出来的结果，其中n是数组的长度，目前数组长度为16，不管这个hash值为多少，经过(n-1) &amp; hash计算出来的i的值一定在n-1之间。刚好是底层数组的合法下标，用i这个下标值去底层数组里面去取值，如果为null，创建一个Node放到数组下标为i的位置。这里的”1”计算出来的i值是2，看图。</p>
<p><img src="https://s1.ax1x.com/2017/11/30/4ekNt.jpg" alt=""></p>
<p>继续添加元素“李四”，“王五”，“赵六”，一切正常，key：“李四”经过(n - 1) &amp; hash算出来在数组下标位置为1，“王五”为7，“赵六”为9，添加完成后如下图</p>
<p><img src="https://s1.ax1x.com/2017/11/30/4eegS.jpg" alt=""></p>
<p>上图是堆内存图。继续往里添加”孙七”，通过(n - 1) &amp; hash计算“孙七”这个key时计算出来的下标值是1，而数组下标1这个位置目前已经被“李四”给占了，产生了冲突。相信大家在看本文的过程中也有这样的疑惑，万一计算出来的下标值i重了怎么办？我们来看一看HashMap是怎么解决冲突的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">	<span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">		p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">		<span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">			treeifyBin(tab, hash);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这段代码就是冲突的处理，这一句是关键。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure>
<p>也就是说new一个新的Node对象并把当前Node的next引用指向该对象，也就是说原来该位置上只有一个元素对象，现在转成了单向链表。添加完所有的元素如下图</p>
<p><img src="https://s1.ax1x.com/2017/11/30/4eGCV.jpg" alt=""></p>
<p>到这里所有的元素添加完，我们Ddebug看下。</p>
<p><img src="https://s1.ax1x.com/2017/11/30/4eJ3T.jpg" alt=""></p>
<p>大框里的内容是链表的体现，小框里的内容是单元素的体现。</p>
<p>红框中还有两行比较重要的代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">//当binCount&gt;=TREEIFY_THRESHOLD-1</span></span><br><span class="line">     treeifyBin(tab, hash);<span class="comment">//把链表转化为红黑树</span></span><br></pre></td></tr></table></figure>
<p>TREEIFY_THRESHOLD的值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br></pre></td></tr></table></figure>
<p>当链表长度为8时，将链表转换为红黑树来处理。树在内存中的样子。</p>
<p><img src="https://s1.ax1x.com/2017/11/30/4eaDJ.png" alt=""></p>
<p>在JDK1.7及以前的版本中，HashMap里是没有红黑树的实现的，在JDK1.8中加入了红黑树是为了防止哈希表碰撞攻击，当链表链长度为8时，及时转成红黑树，提高map的效率。</p>
<p>思考以下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>hash方法的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> h;</span><br><span class="line">	<span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在put放入元素时，HashMap又自己写了一个hash方法来计算hash值，为什么不用key本身的hashCode方法，而是又处理了一下？</p>
<p>这段代码叫“扰动函数”</p>
<p>具体细节请前往下面这个链接看：<br>看它<br><img src="https://s1.ax1x.com/2017/11/30/4mlse.png" alt=""><br><a href="https://www.zhihu.com/question/20733617" target="_blank" rel="noopener">https://www.zhihu.com/question/20733617</a></p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>HashMap的最底层是数组实现的，数组里的元素可能为null，也可能是单个对象，还有可能是单向链表或者红黑树。文中的resize在底层数组为null的时候会初始化一个数组，不为null的情况下会去扩容底层数组，并会重排底层数组里的元素。</p>
<p>本文参考：<a href="https://zhuanlan.zhihu.com/p/28501879" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/28501879</a><br>建议去看看他的系列，写的通俗易懂。</p>
]]></content>
      
        <categories>
            
            <category> Java基础 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[栈与队列]]></title>
      <url>/Stack-and-Queue/</url>
      <content type="html"><![CDATA[<h2 id="栈的定义"><a href="#栈的定义" class="headerlink" title="栈的定义"></a>栈的定义</h2><blockquote>
<p>栈是限定仅在表尾进行插入和删除操作的线性表</p>
</blockquote>
<a id="more"></a>
<blockquote>
<p>我们把允许插入和删除的一端称为栈顶 (top) ，另一端称为栈底 (bottom) ，不含任何数据元素的栈称为空栈。 栈又称为后进先出 (Last In Filrst Out) 的线性表，简称LIFO结构。</p>
<p>理解栈的定义需要注意：<br>首先它是一个线性表，也就是说，栈元素具有线性关系，即前驱后继关系。只不过它是一种特殊的线性表而已。定义中说是在线性表的表尾进行插入和删除操作，这里表尾是指栈顶，而不是栈底。</p>
<p>它的特殊之处就在于限制了这个线性表的插入和删除位置，它始终只在栈顶进行。这就使得：栈底是固定的，最先进栈的只能在栈底。</p>
<p>栈的插入操作，叫做进栈，也称压栈、入栈。类似子弹入弹夹，如图4-2-2所示。</p>
<p>栈的删除操作，叫做出栈，也有叫做弹栈。如同弹夹中的子弹出夹，如图4-2-3所示。<br><img src="https://s1.ax1x.com/2017/11/29/h7EAx.png" alt=""></p>
</blockquote>
<h3 id="进栈出栈变化形式"><a href="#进栈出栈变化形式" class="headerlink" title="进栈出栈变化形式"></a>进栈出栈变化形式</h3><blockquote>
<p>现在我要问问大家，这个最先进栈的元素，是不是就只能是最后出战呢?<br>答案是不一定，要看什么情况。栈对线性表的插入和删除的位置进行了限制 ，并没有对元素进出的时间进行限制，也就是说，在不是所有元素都进栈的情况下，事先进去的元素也可以出栈，只要保证是栈顶元素出栈就可以。</p>
<p>举例来说，如果我们现在是有 3 个整型数字元素 1、 2、 3 依次进栈，会有哪些出栈次序呢?</p>
</blockquote>
<p><img src="http://p05qxk5gj.bkt.clouddn.com/2.jpg" alt=""></p>
<blockquote>
<p>有没有可能是 312 这样的次序出栈呢？答案是肯定不会。因为 3 先出栈，就意味着，3曾经进栈，既然 3 都进栈了，那也就意味着， 1 和 2 已经进栈了，此时， 2 一 定是在 1 的上面，就是更接近栈顶，那么出栈只可能是 321，不然不满足 123 依次进栈的要求，所以此时不会发生1比2先出栈的情况。</p>
<p>从这个简单的例子就能看出，只是 3 个元素，就有 5 种可能的出栈次序，如果元素数量多，其实出栈的变化将会更多的。这个知识点一定要弄明白。</p>
</blockquote>
<h2 id="栈的抽象数据类型"><a href="#栈的抽象数据类型" class="headerlink" title="栈的抽象数据类型"></a>栈的抽象数据类型</h2><blockquote>
<p>对于栈来讲，理论上线性表的操作特性它都具备，可由于它的特殊性，所以针对它在操作上会有些变化。特别是插入和删除操作，我们改名为push 和pop，英文直译的话是压和弹，更容易理解。你就把它当成是弹夹的子弹压入和弹出就好记忆了，我 们一般叫进栈和出栈。<br><img src="http://p05qxk5gj.bkt.clouddn.com/3.jpg" alt=""><br>由于栈本身就是一个线性表，那么上一章我们讨论了线性表的顺序存储和链式存储，对于栈来说，也是同样适用的。</p>
</blockquote>
<h2 id="栈的顺序存储结构及实现"><a href="#栈的顺序存储结构及实现" class="headerlink" title="栈的顺序存储结构及实现"></a>栈的顺序存储结构及实现</h2><h3 id="栈的顺序存储结构"><a href="#栈的顺序存储结构" class="headerlink" title="栈的顺序存储结构"></a>栈的顺序存储结构</h3><blockquote>
<p>栈的顺序存储其实也是线性表顺序存储的简化，我们简称为顺序栈。线性表是用数组来实现的，用下标0的一端作为栈底。因为首元素都在栈底，变化最小，所以让它作栈底。</p>
<p>定义一个top变量来指示栈顶元素在数组中的位置。存储栈的长度胃StackSize，则栈顶位置top必须小于StackSize。当栈存在一个元素时，top等于0，因此通常把空栈的判断条件定为top=-1。</p>
<p>若现在有一个栈，StackSize是5，则栈普通情况、空栈和栈满的情况示意图如图4-4-2所示。<br><img src="http://p05qxk5gj.bkt.clouddn.com/4.jpg" alt=""></p>
</blockquote>
<h4 id="栈的顺序存储结构一一进栈操作"><a href="#栈的顺序存储结构一一进栈操作" class="headerlink" title="栈的顺序存储结构一一进栈操作"></a>栈的顺序存储结构一一进栈操作</h4><p><img src="http://p05qxk5gj.bkt.clouddn.com/5.jpg" alt=""></p>
<h4 id="栈的顺序存储结构一一出栈操作"><a href="#栈的顺序存储结构一一出栈操作" class="headerlink" title="栈的顺序存储结构一一出栈操作"></a>栈的顺序存储结构一一出栈操作</h4><p><img src="http://p05qxk5gj.bkt.clouddn.com/27.jpg" alt=""></p>
<p>两者没有涉及到任何循环语句，因此时间复杂度O(1)。</p>
<h2 id="两栈共享空间"><a href="#两栈共享空间" class="headerlink" title="两栈共享空间"></a>两栈共享空间</h2><blockquote>
<p>栈的顺序存储是很方便，因为它只准栈顶进出元素，所以不存在线性表插入和删除时需要移动元素的问题。不过它有一个很大的缺陷，就是必须实现确定数组存储空间大小，万一不够用了，就需要编码手段来扩展数组的容量，非常麻烦。对于一个栈，我们也只能尽量考虑周全，设计出合适大小的数组来处理，但对于两个相同类型的栈，我们却可以做到最大限度地利用其事先开辟的存储空间来进行操作。<br>如果我们有两个相同类型的栈，我们为它们各自开辟了数组空间，极有可能是第一个栈已经满了，再进栈就溢出了，而另一个栈还有很多存储空间空闲。这又何必呢？我们完全可以用一个数组来存储两个栈，只不过需要一点技巧。<br>我们的做法如图4-5-1，数组有两个端点，两个栈有两个栈底，让一个栈的栈底为数组的始端，即下标为0处，另一个栈为栈的末端，即下标为数组长度n-1处。这样，两个栈如果增加元素，就是两端点向中间延伸。<br><img src="http://p05qxk5gj.bkt.clouddn.com/6.jpg" alt=""></p>
<p>关键思路是：它们是在数组的两端，向中间靠拢。top1和top2是栈1和栈2的栈顶指针，可以想象，只要它们俩不见面，两个栈就可以一直使用。<br>从这里也可以分析出，栈1为空时，就是top1=-1时；而当top2=n时，即是栈2为空时，那什么时候栈满呢？<br>想想极端的情况，若栈2是空栈，栈1的 top1 等于 n-1 时，就是栈1满了。 反之，当栈1为空栈时， top2等于0时，为栈2满。但更多的情况，其实就是我刚才说的，两个栈见面之时，也就是两个指针之间相差 1 时，即top + 1 == top2为栈满。</p>
<p>对于两栈共享空间的 push 方法，我们除了要插入元素值参数外，还需要有一个判断是栈1还是栈2的栈号参数 stackNumber。</p>
<p>使用这样的数据结构，通常都是当两个栈的空间需求有相反关系时，也就是一个栈增长时另一个栈在缩短的情况。这样使用两栈共享存储方法才有比较大的意义。否则两个栈都在不停地增长，那很快就会因栈满而溢出。</p>
<p>当然这只针对两个具有相同数据类型的栈的一个设计上的技巧，如果是不相同数据类型的栈，这种办法不但不能更好地处理问题，反而会使问题变得更复杂，要注意这个前提。</p>
</blockquote>
<h2 id="栈的链式存储结构及实现"><a href="#栈的链式存储结构及实现" class="headerlink" title="栈的链式存储结构及实现"></a>栈的链式存储结构及实现</h2><h3 id="栈的链式存储结构"><a href="#栈的链式存储结构" class="headerlink" title="栈的链式存储结构"></a>栈的链式存储结构</h3><p><strong>栈的链式存储结构，简称为链栈。</strong></p>
<blockquote>
<p>想想看，栈只是栈顶来做插入和删除操作，栈顶放在链表的头部还是尾部呢?由于单链表有头指针，而栈顶指针也是必须的，那干吗不让它俩合二为一呢，所以比较好的办法是把栈顶放在单链表的头部(如图 4-6-1 所示)。另外，都已经有了栈顶在头部了，单链表中比较常用的头结点也就失去了意义，通常对于链栈来说，是不需要头结点的。</p>
</blockquote>
<p><img src="http://p05qxk5gj.bkt.clouddn.com/7.jpg" alt=""></p>
<p>对于链栈来说，基本不存在栈满的情况，除非内存已经没有可以使用的空间，如果真的发生，那此时的计算机操作系统已经面临死机崩溃的情况，而不是这个链栈是否溢出的问题。<br>但对于空栈来说，链表原定义是头指针指向空，那么链栈的空其实就是 top=NULL的时候。</p>
<h4 id="栈的链式存储结构一一进栈操作"><a href="#栈的链式存储结构一一进栈操作" class="headerlink" title="栈的链式存储结构一一进栈操作"></a>栈的链式存储结构一一进栈操作</h4><blockquote>
<p>对于链栈的进栈 push 操作，假设元素值为 e 的新结点是 S， top 为栈顶指针，示意图如图 4-6-2 所示代码如下。</p>
</blockquote>
<p><img src="http://p05qxk5gj.bkt.clouddn.com/28.jpg" alt=""></p>
<p><img src="http://p05qxk5gj.bkt.clouddn.com/1511935354%281%29.jpg" alt=""></p>
<h4 id="栈的链式存储结构一一出栈操作"><a href="#栈的链式存储结构一一出栈操作" class="headerlink" title="栈的链式存储结构一一出栈操作"></a>栈的链式存储结构一一出栈操作</h4><blockquote>
<p>假设变量 p 用来存储要删除的钱顶结点，将栈顶指针下移一位，最后释放 p 即可，如图 4-6-3 所示。<br><img src="http://p05qxk5gj.bkt.clouddn.com/9.jpg" alt=""></p>
</blockquote>
<p><img src="http://p05qxk5gj.bkt.clouddn.com/efwef.jpg" alt=""></p>
<blockquote>
<p>链栈的进栈push和出栈pop操作都很简单，没有任何循环操作，时间复杂度均为O(1)。</p>
<p>对比一下顺序栈与链栈，它们在时间复杂度上是一样的，均为O(1)。对于空间性能，顺序栈需要事先确定一个固定的长度，可能会存在内存空间浪费的问题，但它的优势是存取时定位很方便，而链栈则则要求每个元素都有指针域，这同时也增加了一些内存开销，但对于栈的长度无限制。所以它们的区别和线性表中讨论的是一样，<strong>如果栈的使用过程中元素变化不可预料，有时很小，有时非常大，那么最好是用链栈，反之，如果它的变化在可控范围内，建议使用顺序栈会好一些。</strong></p>
</blockquote>
<h2 id="栈的作用"><a href="#栈的作用" class="headerlink" title="栈的作用"></a>栈的作用</h2><blockquote>
<p>栈的引人简化了程序设计的问题，划分了不同关注层次，使得思考范围缩小，更加聚焦于我们要解决的问题核心。反之，像数组等，因为要分散精力去考虑、数组的下标增减等细节问题，反而掩盖了问题的本质。</p>
<p>所以现在的许多高级语言，比如 )ava、 C#等都有对栈结构的封装， 你可以不用关注它的实现细节，就可以直接使用 Stack 的 push 和 pop 方法，非常方便。</p>
</blockquote>
<h2 id="栈的应用一一递归"><a href="#栈的应用一一递归" class="headerlink" title="栈的应用一一递归"></a>栈的应用一一递归</h2><h3 id="递归的定义"><a href="#递归的定义" class="headerlink" title="递归的定义"></a>递归的定义</h3><blockquote>
<p>我们把一个直接调用自己或通过一系列的调用语句间接地调用自己的函数，称做递归函数。</p>
<p>队列(queue)是只允许在一端进行插入操作，而在另一端进行删除操作的线性表。<br>队列是一种先进先出(First In First Out)的线性表，简称FIFO。允许插入的一端称为队尾，允许删除的一端称为队头。</p>
<p>当然，写递归程序最怕的就是陷入永不结束的无穷递归中 ， 所以， 每个递归定义必须至少有一个条件，满足时递归不再进行，即不再引用自身而是返回值退出。 比如刚才的例子，总有一次递归会使得 i&lt;2 的，这样就可以执行return i 的语句而不用继续递归了。</p>
<p>选代和递归的区别是:迭代使用的是循环结构，递归使用的是选择结构。递归能使程序的结构更清晰、更简洁、更容易让人理解，从而减少读懂代码的时间。但是大量的递归调用会建立函数的副本，会耗费大量的时间和内存。选代则不需要反复调用函数和占用额外的内存。因此我们应该视不同情况选择不同的代码实现方式。</p>
</blockquote>
<p><strong>递归与栈之间有什么关系？</strong></p>
<blockquote>
<p>前面我们已经看到递归是如何执行宫的前行和退回阶段的。递归过程退回的顺序是它前行顺序的逆序。在退回过程中，可能要执行某些动作，包括恢复在前行过程中存储起来的某些数据。</p>
<p>这种存储某些数据，并在后面又以存储的逆序恢复这些数据，以提供之后使用的 需求，显然很符合钱这样的数据结构，因此， 编译器使用植实现递归就没什么好惊讶的了。</p>
<p>简单的说，就是在前行阶段，对于每一层递归，函数的局部变量、参数值以及返 回地址都被压入栈中。在退回阶段，位于栈顶的局部变量、 参数值和返回地址被弹 出，用于返回调用层次中执行代码的其余部分，也就是恢复了调用的状态。</p>
</blockquote>
<h2 id="栈的应用一一四则运算表达式求值"><a href="#栈的应用一一四则运算表达式求值" class="headerlink" title="栈的应用一一四则运算表达式求值"></a>栈的应用一一四则运算表达式求值</h2><blockquote>
<p>后缀(逆波兰)表示法定义</p>
<p>我们举个例子，对于”9+ (3-1) X3+10-:-2”，如果要用后缀表示法应该是什么样子:”931-3*+102/+”，这样的表达式称为后缀表达式，叫后缀的原因在于所有的符号都是在要运算数字的后面出现。显然，这里没有了括号。</p>
</blockquote>
<h3 id="后缀表达式计算结果"><a href="#后缀表达式计算结果" class="headerlink" title="后缀表达式计算结果"></a>后缀表达式计算结果</h3><p>为了解释后缀表达式的好处，我们先来看看，计算机是如何应用后缀表达式计算最终的结果20的。<br>    后缀表达式：931-3*+102/+<br>规则：:从左到右遍历表达式的每个数字和符号，遇到是数字就进枝，遇到是符号，就将处于桔顶两个数字出拢，进行运算，运算结果进钱，一直到最终获得结果。</p>
<ol>
<li>初始化一个空技J 此钱用来对要运算的数字进出使用。如图4-9-1的左图所示</li>
<li>后缀表达式中前三个都是数字，所以9、3、1进栈，如图4-9-1的右图所示。</li>
</ol>
<p><img src="https://s1.ax1x.com/2017/11/29/h7IV1.png" alt=""></p>
<ol>
<li>接下来是”-“，所以将栈中的1出栈作为减数，3出栈作为被减数，并运算3-1得到2，再将2进栈，如图4-9-2的左图所示。</li>
<li>接着是数字3进栈，如图4-9-2的右图所示。<br><img src="https://s1.ax1x.com/2017/11/29/h7oUx.png" alt=""> </li>
<li>后面是”*”，也就意味着栈中3和2出栈， 2与3相乘，得到6，并将 6进栈，如图4-9-3的左图所示。</li>
<li>下面是”+”，所以栈中6和9出栈，9与6相加，得到15，将15进栈，如图4-9-3的右图所示。</li>
</ol>
<p><img src="https://s1.ax1x.com/2017/11/29/h7HPK.png" alt=""></p>
<ol>
<li>接着10和2两数字进栈，如图4-9-4的左图所示。</li>
<li>接下来是符号”/“，因此，栈顶的2与10出栈，10与2相除，得到5，将5进栈，如图4-9-4右图所示。</li>
</ol>
<p><img src="https://s1.ax1x.com/2017/11/29/h7q2D.png" alt=""></p>
<ol>
<li>最后一个是符号”+”，所以15与5出栈并相加，得到20，将20进栈，如图4-9-5的左图所示</li>
<li>结果是20出栈，栈变为空，如图4-9-5的右图所示。</li>
</ol>
<p><img src="https://s1.ax1x.com/2017/11/29/h7Lxe.png" alt=""></p>
<p><strong>中缀表达式转后缀表达式（具体百度）</strong></p>
<h2 id="队列的定义"><a href="#队列的定义" class="headerlink" title="队列的定义"></a>队列的定义</h2><blockquote>
<p>队列 ( queue ) 是只允许在一端进行插入操作，而在另一端进行删除操作的线性表。<br>队列是一种先进先出 (First In First Out) 的线性表，简称 FIFO。允许插入的一端称为队尾，允许删除的一端称为队头。</p>
</blockquote>
<h2 id="队列的抽象数据类型"><a href="#队列的抽象数据类型" class="headerlink" title="队列的抽象数据类型"></a>队列的抽象数据类型</h2><blockquote>
<p>同样是线性衰，队列也有类似线性表的各种操作，不同的就是插入数据只能在队尾进行，删除数据只能在队头进行。<br><img src="http://p05qxk5gj.bkt.clouddn.com/11.jpg" alt=""></p>
</blockquote>
<h2 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h2><blockquote>
<p>线性表有顺序存储和链式存储，栈是线性表，所以有这两种存储方式。同样，队列作为一种特殊的线性表，也同样存在这两种存储方式。先来看队列的顺序存储结构</p>
</blockquote>
<h3 id="队列顺序存储的不足"><a href="#队列顺序存储的不足" class="headerlink" title="队列顺序存储的不足"></a>队列顺序存储的不足</h3><blockquote>
<p>我们假设一个队列有 n 个元素，则顺序存储的队列需建立一个大于 n 的数组，并把队列的所有元素存储在数组的前 n 个单元，数组下标为 0 的一端即是队头。所谓的 入队列操作，其实就是在队尾追加一个元素，不需要移动任何元素，因此时间复杂度为O(1)，如图4-12-1所示。<br><img src="https://raw.githubusercontent.com/LxRuzx/MarkDownPhoto/master/MarkDownPhoto/12.jpg" alt=""><br>与栈不同的是，队列元素的出列是在队头，即下标为 0 的位置，那也就意味着， 队列中的所有元素都得向前移动，以保证队列的队头，也就是下标为 0 的位置不为空，此时时间复杂度为 O(n)，如图 4-12.-2 所示.<br><img src="https://raw.githubusercontent.com/LxRuzx/MarkDownPhoto/master/MarkDownPhoto/13.jpg" alt=""></p>
<p>可有时想想，为什么出队列时一定要全部移动呢，如果不去限制队列的元素必须 存储在数组的前 n 个单元这一条件，出队的性能就会大大增加。 也就是说，队头不需 要一定在下标为 0 的位置， 如图 4-12-3 所示。<br><img src="https://raw.githubusercontent.com/LxRuzx/MarkDownPhoto/master/MarkDownPhoto/14.jpg" alt=""><br>为了避免当只有一个元素时，队头和队尾重合使处理变得麻烦，所以引入两个指针， front指针指向队头元素，rear指针指向队尾元素的下一个位置，这样当front等于rear时，此队列不是还剩一个元素，而是空队列。 </p>
<p>假设是长度为 5 的数组，初始状态，空队列如图 4-12-4 的左图所示， front 与 rear 指针均指向下标为 0 的位置。 然后入队 a1、 a2、 a3、 a4， front 指针依然指向下标 为 0 位置，而 rear 指针指向下标为 4 的位置，如图 4-12-4 的右图所示。<br><img src="https://raw.githubusercontent.com/LxRuzx/MarkDownPhoto/master/MarkDownPhoto/15.jpg" alt=""></p>
<p>出队 a1、 a2，则 front指针指向下标为 2 的位置， rear 不变，如图 4-12-5 的左图所示，再入队 a5，此时 front 指针不变， rear 指针移动到数组之外。嗯?数组之外， 那将是哪里?如图 4-12-5 的右图所示。<br><img src="https://raw.githubusercontent.com/LxRuzx/MarkDownPhoto/master/MarkDownPhoto/16.jpg" alt=""></p>
<p>问题还不止于此。假设这个队列的总个数不超过 5 个，但目前如果接着入队的话，因数组末尾元素已经占用，再向后加，就会产生数组越界的错误，可实际上，我 们的队列在下标为 0 和 1 的地方还是空闲的。 我们把这种现象叫做”假溢出”。</p>
</blockquote>
<h3 id="循环队列定义"><a href="#循环队列定义" class="headerlink" title="循环队列定义"></a>循环队列定义</h3><blockquote>
<p>我们把队列的这种头尾相接的顺序存储结构称为循环队列。</p>
<p>刚才的例子继续，图 4-12-5 的 rear 可以改为指向下标为 0 的位置，这样就不会造成指针指向不明的问题了，如图 4-12-6 所示。<br><img src="https://raw.githubusercontent.com/LxRuzx/MarkDownPhoto/master/MarkDownPhoto/17.jpg" alt=""></p>
<p>接着入a6，将它放置于下标为 0 处， rear 指针指向下标为 1 处，如图 4-12-7 的左图所示。若再入队a7，则 rear 指针就与front 指针重合，同时指向下标为 2 的位 置，如图 4-12-7 的右图所示。<br><img src="https://raw.githubusercontent.com/LxRuzx/MarkDownPhoto/master/MarkDownPhoto/18.jpg" alt=""></p>
<ul>
<li>此时问题又出来了，我们刚才说，空队列时， fronr =rear，现在当队列满时，也是 front=rear，那么如何判断此时的队列究竟是空还是满呢?</li>
<li>办法一是设置一个标志变量 flag， 当 front == rear，且 flag = 0 时为队列空， 当 front== rear，且 flag= 1 时为队列满。 </li>
<li>办法二是当队列空时，条件就是 front = rear，当队列满时，我们修改其条件，保留一个元素空间。也就是说，队列满时，数组中还有一个空闲单元。 例如图 4-12-8 所示，我们就认为此队列已经满了，也就是说，我们不允许图 4-12-7 的右图情况出现。<br><img src="https://raw.githubusercontent.com/LxRuzx/MarkDownPhoto/master/MarkDownPhoto/19.jpg" alt=""></li>
</ul>
<p>我们重点来讨论第二种方法，由于rear可能比 front大，也可能比front 小，所以尽管它们只相差一个位置时就是满的情况，但也可能是相差整整一圈。 所以若队列的最大尺寸为 QueueSize，那么队列满的条件是 (rear+1) %QueueSize==front (取模”%” 的目的就是为了整合rear与front 大小为一个问题)。比如上面这个例子，QueueSize = 5，图 4-12-8 的左图中 front=0，而 rear=4， (4+1) %5 = 0，所以此时队列满. 再比如图 4-12-8 中的右图， front = 2 而 rear = 1。 (1 + 1) %5 = 2 ，所以此时 队列也是满的。而对于图 4-12-6， front=2 而 rear= 0 , (0+1) %5 = 1 , 1 ≠ 2，所以此时队列并没有满。</p>
<p>另外，当 rear&gt; front 时，即图 4-12-4 的右图和 4-12-5 的左图，此时队列的长度 为 rear-front 但当 rear &lt; front 时，如图 4-12-6 和图 4-12-7 的左图，队列长度分为 两段， 一段是 QueueSize-front， 另一段是 0 + rear，加在一起，队列长度为 rear-front + QueueSize。因此通用的计算队列长度公式为: (rear- front + QueueSize) %QueueSize </p>
</blockquote>
<h2 id="队列的链式存储结构及实现"><a href="#队列的链式存储结构及实现" class="headerlink" title="队列的链式存储结构及实现"></a>队列的链式存储结构及实现</h2><blockquote>
<p>队列的链式存储结构，其实就是线性表的单链表，只不过它只能尾进头出而已， 我们把它简称为链队列。为了操作上的方便，我们将队头指针指向链队列的头结点，而对尾指针指向终端结点，如图4-13-1所示</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/LxRuzx/MarkDownPhoto/master/MarkDownPhoto/20.jpg" alt=""></p>
<blockquote>
<p>空队列时， front 和 rear 都指向头结点，如图 4-13-2 所示。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/LxRuzx/MarkDownPhoto/master/MarkDownPhoto/21.jpg" alt=""></p>
<h3 id="队列的链式存储结构一一入队操作"><a href="#队列的链式存储结构一一入队操作" class="headerlink" title="队列的链式存储结构一一入队操作"></a>队列的链式存储结构一一入队操作</h3><blockquote>
<p>人队操作时，其实就是在链表尾部插入结点，如图 4-13-3 所示。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/LxRuzx/MarkDownPhoto/master/MarkDownPhoto/22.jpg" alt=""></p>
<h3 id="队列的链式存储结构一一出队操作"><a href="#队列的链式存储结构一一出队操作" class="headerlink" title="队列的链式存储结构一一出队操作"></a>队列的链式存储结构一一出队操作</h3><blockquote>
<p>出队操作时，就是头结点的后继结点出队，将头结点的后继改为它后面的结点， 若链表除头结点外只剩一个元素时， 则需将 rear 指向头结点，如图 4-13-4 所示。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/LxRuzx/MarkDownPhoto/master/MarkDownPhoto/23.jpg" alt=""></p>
<blockquote>
<p>对于循环队列与链队列的比较，可以从两方面来考虑，从时间上，其实它们的基 本操作都是常数时间，即都为 0(1)的，不过循环队列是事先申请好空间，使用期间不释放，而对于链队列，每次申请和释放结点也会存在一些时间开销，如果入队出队频 繁，则两者还是有细微差异。对于空间上来说，循环队列必须有一个固定的长度，所以就有了存储元素个数和空间浪费的问题。而链队列不存在这个问题，尽管它需要一个指针域， 会产生一些空间上的开销，但也可以接受。 所以在空间上，链队列更加灵活。<br>总的来说，在可以确定队列长度最大值的情况下 ，建议用循环队列，如果你无法预估队列的长度时，则用链队列。</p>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote>
<p>栈和队列，它们都是特殊的线性表， 只不过对插入和删除操作做了限制。</p>
<p>栈 (stack) 是限定仅在表尾进行插入和删除操作的线性袭。</p>
<p>队列 (queue) 是只允许在一端进行插入操作，而在另一端进行删除操作的线性表。</p>
<p>它们均可以用线性表的顺序存储结构来实现，但都存在着顺序存储的一些弊端。</p>
<p>因此它们各自有各自的技巧来解决这个问题。</p>
<p>对于栈来说，如果是两个相同数据类型的栈，则可以用数组的两端作栈底的方法来让两个栈共享数据，这就可以最大化地利用数组的空间。<br>对于队列来说，为了避免数组插入和删除时需要移动数据，于是就引入了循环队列 ，使得队头和队尾可以在数组中循环变化。解决了移动数据的时间损耗，使得本来插入和删除是 O(n)的时间复杂度变成了O(1)。<br>它们也都可以通过链式存储结构来实现，实现原则上与线性表基本相同如图 4-14-1 所示。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/LxRuzx/MarkDownPhoto/master/MarkDownPhoto/24.jpg" alt=""></p>
]]></content>
      
        <categories>
            
            <category> 数据结构与算法呀~ </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[线性表]]></title>
      <url>/linear-list/</url>
      <content type="html"><![CDATA[<h2 id="线性表的定义"><a href="#线性表的定义" class="headerlink" title="线性表的定义"></a>线性表的定义</h2><blockquote>
<p>线性表：<br>零个或多个数据元素的有限序列</p>
</blockquote>
<a id="more"></a>
<h2 id="线性表的顺序存储结构"><a href="#线性表的顺序存储结构" class="headerlink" title="线性表的顺序存储结构"></a>线性表的顺序存储结构</h2><h3 id="顺序存储结构的定义"><a href="#顺序存储结构的定义" class="headerlink" title="顺序存储结构的定义"></a>顺序存储结构的定义</h3><p>线性表的两种物理结构的第一种一一顺序存储结构。</p>
<blockquote>
<p>线性表的顺序存储结构，指的是用一段地址连续的存储单元依次存储线性表的数据元素。</p>
<p><img src="https://i.imgur.com/4eIJJFc.png" alt=""></p>
</blockquote>
<h3 id="顺序存储方式"><a href="#顺序存储方式" class="headerlink" title="顺序存储方式"></a>顺序存储方式</h3><blockquote>
<p>就是在内存中找了块地，通过占地的形式，把一定内存空间给占了，然后把相同数据类型的数据元素依次存放在这块空地中。</p>
<h3 id="数据长度与线性表长度的区别"><a href="#数据长度与线性表长度的区别" class="headerlink" title="数据长度与线性表长度的区别"></a>数据长度与线性表长度的区别</h3><p>两个概念”数组的长度”和”续性表的长度”需要区分一下。<br>数组的长度是存放线性表的存储空间的长度，存储分配后这个量是一般是不变的。有个别同学可能会问，数组的大小一定不可以变吗?我怎么看到有书中谈到可以动态分配的一维数组。是的，一般高级语言，比如C、VB、 C++都可以用编程手段实现动态分配数组，不过这会带来性能上的损耗。</p>
<p>线性表的长度是线性表中数据元素的个数，随着线性表插入和删除操作的进行，这个量是变化的。<br>在任意时刻，线性表的长度应该小于等于数组的长度。</p>
</blockquote>
<h3 id="地址计算方法"><a href="#地址计算方法" class="headerlink" title="地址计算方法"></a>地址计算方法</h3><blockquote>
<p>由于我们数数都是从 1 开始数的，线性表的定义也不能免俗，起始也是 1， 可 C 语言中的数组却是从 0 开始第一个下标的，于是线性表的第 i 个元素是要存储在数组下标为 i-1 的位置，即数据元素的序号和存放它的数组下标之间存在对应关系<br>(如下图所示)。</p>
</blockquote>
<p><img src="https://i.imgur.com/WXBZZyz.png" alt=""></p>
<blockquote>
<p>用数组存储顺序表意味着要分配固定长度的数组空间，由于线位表中可以进行插 入和删除操作，因此分配的数组空间要大于等于当前线性表的长度。</p>
<p>其实，内存中的地址，就和图书馆或电影院里的座位一样，都是有编号的。 存储器中的每个存储单元都有自己的编号，这个编号称为地址。当我们占座后，占座的第一个位置确定后，后面的位置都是可以计算的。 试想一下，我是班级成绩第五名，我后面的 10 名同学成绩名次是多少呢?当然是 6， 7 ，…、 15 ，因为 5 + 1 , 5 + 2,…, 5 + 10。由于每个数据元素，不管它是整型、实型还是字符型，它都是需要占用一定的存储单元空间的。假设占用的是c个存储单元，那么线性表中第 i+1 个数据元素的存储位置和第 i 个数据元素的存储位置满足下列关系 (LOC 表示获得存储位置的函数)。</p>
</blockquote>
<p><img src="https://i.imgur.com/QfleP8c.png" alt=""></p>
<blockquote>
<p>通过这个公式，你可以随时算出线性表中任意位置的地址，不管它是第一个还是 最后一个，都是相同的时间。 那么我们对每个线性表位置的存入或者取出数据， 对于计算机来说都是相等的时间， 也就是一个常数，因此用我们算法中学到的时间复杂度的概念来说，它的存取时间性能为 0(1)。我们通常把具有这一特点的存储结构称为随机存取结构。</p>
</blockquote>
<h3 id="顺序存储结构的插入与删除"><a href="#顺序存储结构的插入与删除" class="headerlink" title="顺序存储结构的插入与删除"></a>顺序存储结构的插入与删除</h3><blockquote>
<p>插入算法的思路; </p>
<ul>
<li>如果插入位置不合理，抛出异常;</li>
<li>如果线性表长度大于等于数组长度，则抛出异常或动态增加容量;</li>
<li>从最后一个元素开始向前遍历到第 i 个位置，分别将它们都向后移动一个位 置;</li>
<li>将要插入元素填入位置 i 处; </li>
<li>表长加 1。</li>
</ul>
<p>删除算法的思路:</p>
<ul>
<li>如果删除位置不合理，抛出异常i</li>
<li>取出删除元素;</li>
<li>从删除元素位置开始遍历到最后一个元素位置，分别将它们都向前移动一 个位置;</li>
<li>表长减 1。</li>
</ul>
<p>插入与删除的时间复杂度</p>
<p><img src="http://p05qxk5gj.bkt.clouddn.com/17-11-29/7750405.jpg" alt=""></p>
</blockquote>
<h3 id="线性表顺序存储口结构的优缺点"><a href="#线性表顺序存储口结构的优缺点" class="headerlink" title="线性表顺序存储口结构的优缺点"></a>线性表顺序存储口结构的优缺点</h3><p><img src="http://p05qxk5gj.bkt.clouddn.com/1511921076%281%29.jpg" alt=""></p>
<h2 id="线性表的链式存储结构"><a href="#线性表的链式存储结构" class="headerlink" title="线性表的链式存储结构"></a>线性表的链式存储结构</h2><h3 id="顺序存储结构不足的解决办法"><a href="#顺序存储结构不足的解决办法" class="headerlink" title="顺序存储结构不足的解决办法"></a>顺序存储结构不足的解决办法</h3><blockquote>
<p>我们反正也是要让相邻元素间留有足够余地，那干脆所有的元素都不要考虑相邻位置了，哪有空位就到哪里，而只是让每个元素知道它下一个元素的位置在哪里，这样，我们可以在第一个元素时，就知道第二个元素的位置(内存地址) , 而找到它; 在第二个元素时，再找到第三个元素的位置(内存地址)。这样所有的元素我们就都可以通过遍历而找到。</p>
</blockquote>
<h3 id="线性表链式存储结构定义"><a href="#线性表链式存储结构定义" class="headerlink" title="线性表链式存储结构定义"></a>线性表链式存储结构定义</h3><blockquote>
<p>单线索，无分支的情况。<br>线性表的链式存储结构的特点是用一组任意 的存储单元存储线性表的数据元素，这组存储单 元可以是连续的，也可以是不连续的。这就意味 着，这些数据元素可以存在内存未被占用的任意位置<br>(如下图所示)。</p>
<p>在顺序结构中，每个数据元素只需要存数据元素信息就可以了。现在链式结构中，除了要存数据元素信息外， 还要存储它的后继元素的存储地址。<br><img src="http://p05qxk5gj.bkt.clouddn.com/1511921093%281%29.jpg" alt=""></p>
</blockquote>
<p><img src="http://p05qxk5gj.bkt.clouddn.com/1511923022%281%29.jpg" alt=""></p>
<blockquote>
<p>有时，我们为了更加方便地对链表进行操作，会在单链表的第一个结点前附设一个结点，称为头结点。头结点的数据域可以不存储任何信息，谁叫它第一个呢，有这个特权。也可以存储如线性表的长度等附加信息，头结点的指针域存储指向第一个结点的指针，如下图所示</p>
</blockquote>
<p><img src="http://p05qxk5gj.bkt.clouddn.com/1511923113%281%29.jpg" alt=""></p>
<h3 id="头指针与头结点的异同"><a href="#头指针与头结点的异同" class="headerlink" title="头指针与头结点的异同"></a>头指针与头结点的异同</h3><p><img src="http://p05qxk5gj.bkt.clouddn.com/1511923172%281%29.jpg" alt=""></p>
<h3 id="线性表链式存储结构代码描述"><a href="#线性表链式存储结构代码描述" class="headerlink" title="线性表链式存储结构代码描述"></a>线性表链式存储结构代码描述</h3><p><img src="http://p05qxk5gj.bkt.clouddn.com/1511923179%281%29.jpg" alt=""></p>
<p><img src="http://p05qxk5gj.bkt.clouddn.com/1511923224%281%29.jpg" alt=""></p>
<p><img src="http://p05qxk5gj.bkt.clouddn.com/1511923239%281%29.jpg" alt=""></p>
<h2 id="单链表的读取"><a href="#单链表的读取" class="headerlink" title="单链表的读取"></a>单链表的读取</h2><p>获得链表第i个数据的算法思路：</p>
<ol>
<li>声明一个结点p指向链表第一个结点，初始化j从1开始；</li>
<li>当j&lt;i时，就遍历链表，让p的指针向后移动，不断指向下一个结点，j累加1；</li>
<li>若到链表末尾p为空，则说明第i个元素不存在；</li>
</ol>
<blockquote>
<p>说白了，就是从头开始找，直到第 i 个元素为止。由于这个算法的时间复杂度取 决于 i 的位置，当 i=l 肘，则不幡遍历，第一个就取出数据了，而当 i=n 时则遍历 n-1 次才可以。 因此最坏情况的时间复杂度是 O(n)。</p>
<p>由于单链袤的结构中没有定义表长，所以不能事先知道要循环多少次，因此也就 不方便使用 for 来控制循环。其主要核心思想就是 <strong>“工作指针后移”</strong>，这其实也是很多 算法的常用技术。</p>
</blockquote>
<h2 id="单链表的插入与删除"><a href="#单链表的插入与删除" class="headerlink" title="单链表的插入与删除"></a>单链表的插入与删除</h2><h3 id="单链表的插入"><a href="#单链表的插入" class="headerlink" title="单链表的插入"></a>单链表的插入</h3><p><img src="http://p05qxk5gj.bkt.clouddn.com/1511923605%281%29.jpg" alt=""><br><img src="http://p05qxk5gj.bkt.clouddn.com/1511923847%281%29.jpg" alt=""><br><img src="http://p05qxk5gj.bkt.clouddn.com/1511923962%281%29.jpg" alt=""></p>
<blockquote>
<p>单链表第i个数据插入结点的算法思路：</p>
<ol>
<li>声明一结点p指向链表第一个结点，初始化j从1开始；</li>
<li>当j&lt;1时，就遍历链表，让p的指针向后移动，不断指向下一个结点，j累加1；</li>
<li>若到链表末尾p为空，则说明第i个元素不存在；</li>
<li>否则查询成功，在系统中生成一个空结点s；</li>
<li>将数据元素 e 赋值给 s-&gt;data ;</li>
<li>单链表的插入标准语旬 s-&gt;next=p-&gt;next ；p-&gt;next=s; </li>
<li>返回成功。</li>
</ol>
</blockquote>
<h3 id="单链表的删除"><a href="#单链表的删除" class="headerlink" title="单链表的删除"></a>单链表的删除</h3><p><img src="http://p05qxk5gj.bkt.clouddn.com/1511924072%281%29.jpg" alt=""><br><img src="http://p05qxk5gj.bkt.clouddn.com/1511924082%281%29.jpg" alt=""></p>
<blockquote>
<p>单链表第 i 个数据删除结点的算法思路:</p>
<ol>
<li>声明一结点 p 指向链表第一个结点 ， 初始化 j 从 1 开始j</li>
<li>当j&lt;1时， 就遍历链表，让 p 的指针向后移动，不断指向下一个结点 ，j累加1；</li>
<li>若链表末尾p为空，则说明第i个元素不存在；</li>
<li>否则查找成功，将欲删除的结点p-&gt;next赋值给q；</li>
<li>单链表的删除标准p-&gt;next=q-&gt;next;</li>
<li>将q结点中的数据赋值给e,作为返回；</li>
<li>释放q结点；</li>
</ol>
<p>分析一下刚才我们讲解的单链表插入和删除算法，我们发现，官们其实都是由两部分组成;第一部分就是遍历查找第 i 个元素；第二部分就是插入和删除元素。<br>从整个算法来说，我们很容易推导出：它们的时间复杂度都是 O(n)。如果在我们不知道第 i 个元素的指针位置，单链表数据结构在插入和删除操作上，与线性表的顺序存储结构是没有太大优势的。但如果，我们希望从第 i 个位置，插入 10 个元素，对于顺序存储结构意味着，每一次插入都需要移动 n一i 个元素，每次都是 O(n)。而单链表，我们只需要在第一次时，找到第 i 个位置的指针，此时为 O(n)，接下来只是简单地通过赋值移动指针而已，时间复杂度都是 0(1)。显然，对于插入或删除数据越频繁的操作，单链表的效率优势就越是明显。</p>
</blockquote>
<h3 id="单链表的整表创建"><a href="#单链表的整表创建" class="headerlink" title="单链表的整表创建"></a>单链表的整表创建</h3><blockquote>
<p>回顾一下， 顺序存储结构的创建，其实就是一个数组的初始化，即声明一个类型和大小的数组并赋值的过程。而单链表和顺序存储结构就不一样，它不像顺序存储结构这么集中，它可以很散，是一种动态结构。对于每个链表来说，它所占用空间的大小和位置是不需要预先分配划定的，可以根据系统的情况和实际的需求即时生成。<br>所以创建单链表的过程就是一个动态生成链表的过程。即从”空表”的初始状态起，依次建立各元素结点，并逐个插入链衰。</p>
<p>单链表整表创建的算法思路:</p>
<ol>
<li>声明一结点 p 和计数器变量 i;</li>
<li>初始化一空链表 L;</li>
<li>让 L 的头结点的指针指向 NULL，即建立一个带头结点的单链表；</li>
<li>循环:</li>
</ol>
<ul>
<li>生成一新结点赋值给 p;</li>
<li>随机生成一数字赋值给 p 的数据域 p-&gt;data;</li>
<li>将 p 插入到头结点与前一新结点之间。</li>
</ul>
</blockquote>
<p>头插法：就是始终让新结点在第一的位置。<br><img src="http://p05qxk5gj.bkt.clouddn.com/1511924169%281%29.jpg" alt=""></p>
<p>尾插法：我们把每次新结点都插在终端结点的后面。</p>
<h3 id="单链表的整表删除"><a href="#单链表的整表删除" class="headerlink" title="单链表的整表删除"></a>单链表的整表删除</h3><blockquote>
<p>单链表整表删除的算法思路如下:</p>
<ol>
<li>声明一结点 p和 q;</li>
<li>将第一个结点赋值给 p;</li>
<li>循环:</li>
</ol>
<ul>
<li>将下一结点赋值给 q; </li>
<li>释放 p; </li>
<li>将 q 赋值给 p。</li>
</ul>
</blockquote>
<h3 id="单链表结构与顺序存储结构优缺点"><a href="#单链表结构与顺序存储结构优缺点" class="headerlink" title="单链表结构与顺序存储结构优缺点"></a>单链表结构与顺序存储结构优缺点</h3><p>简单地对单链表结构和顺序存储结构做对比：</p>
<ol>
<li>存储分配方式</li>
</ol>
<ul>
<li>顺序存储结构用一段连续的存储单元依次存储线性表的数据元素</li>
<li>单链表采用链式存储结构，用一组任意的存储单元存放线性表的元素</li>
</ul>
<ol>
<li>时间性能</li>
</ol>
<ul>
<li>查找<pre><code>- 顺序存储结构O(1)
- 单链表O(n)
</code></pre></li>
<li>插入和删除<pre><code>- 顺序存储结构需要平均移动表长一半的元素，时间为O(n)
- 单链表在线出某位置的指针后，插入和删除时间仅为O(1)
</code></pre></li>
</ul>
<ol>
<li>空间性能</li>
</ol>
<ul>
<li>顺序存储结构需要预分配存储空间，分大了，浪费，分小了易发生上溢</li>
<li>单链表不需要分配存储空间，只要有就可以分配，元素个数也不受限制</li>
</ul>
<p>通过上面的对比，我们可以得出一些经验性的结论：</p>
<ul>
<li>若线性表需要频繁查找，很少进行插入和删除操作时，宜采用顺序存储结构。若需要频繁插入和删除时，宜采用单链表结构。</li>
<li>当线性表中的元素个数变化较大或者根本不知道有多大时，最好用单链表结构，这样可以不需要考虑存储空间大小的问题。而如果事先知道线性表的大致长度，比如一年十二个月，一周就是七天，这种顺序存储结构效率会高很多。<blockquote>
<p>总之，线性表的顺序存储结构和单链表结构各有其优缺点，不能简单的说哪个好，哪个不好，需要根据实际情况，来综合平衡采用哪种数据结构更能满足和达到需求和性能。</p>
</blockquote>
</li>
</ul>
<h2 id="静态链表"><a href="#静态链表" class="headerlink" title="静态链表"></a>静态链表</h2><blockquote>
<p>首先我们让数组的元素都是由两个数据域组成， data和cur。也就是说，数组的每个下标都对应一个也data和一个cur。数据域data，用来存放数据元素， 也就是通常我们要处理的数据;而游标cur相当于单链表中的next指针，存放该元素的后继在数组中的下标。</p>
<p>我们把这种用数组描述的链表叫做静态链表，这种描述方法还有起名叫做游标实现法。</p>
<p>为了我们方便插入数据，我们通常会把数组建立得大一些，以便有一些空闲空间可以便于插入时不至于溢出。</p>
<p>另外我们对数组第一个和最后一个元素作为特殊元素处理，不存数据。我们通常把未被使用的数组元素称为备用链表。而数组第一个元素，即下标为0的元素的cur就存放备用链表的第一个结点的下标；而数组的最后一个元素的cur则存放第一个有数值的元素的下标，相当于单链表中的头结点作用，当整个链表为空时，则为O²。如下图所示<br><img src="http://p05qxk5gj.bkt.clouddn.com/1511924214%281%29.jpg" alt=""></p>
<p>假设我们已经将数据存入静态链袭，比如分别存放着”甲”、 “乙”、 “丁”、”戊”、 “己”、”庚” 等数据<br><img src="http://p05qxk5gj.bkt.clouddn.com/1511924221%281%29.jpg" alt=""></p>
<p>此时”甲”这里就存有下一元素”乙” 的游标2，”乙”则存有下一元素”丁’的 下标 3。而”庚”是最后一个有值元素，所以它的 cur 设置为 0。而最后一个元素的 cur 则因”甲’是第一有值元素而存有它的下标为 1。 而第一个元素则因空闲空间的第一个元素下标为7 ，所以它的 cur 存有 7。</p>
</blockquote>
<h3 id="静态链表的插入操作"><a href="#静态链表的插入操作" class="headerlink" title="静态链表的插入操作"></a>静态链表的插入操作</h3><blockquote>
<p>静态链表中要解决的是: 如何用静态模拟动态链表结构的存储空间的分配，需要时申请， 无用时释放。</p>
<p>我们前面说过，在动态链表中，结点的申请和释放分别借用 malloc ()和 free()两个函数来实现。在静态链表中，操作的是数组，不存在像动态链表的结点申请和释放问题，所以我们需要自己实现这两个函数，才可以做插入和删除的操作。</p>
<p>为了辨明数组中哪些分量未被使用，解决的办法是将所有未被使用过的及已被删除的分量用游标链成一个备用的链表， 每当进行插入时，便可以从备用链表上取得第一个结点作为待插入的新结点。<br><img src="http://p05qxk5gj.bkt.clouddn.com/1511924230%281%29.jpg" alt=""></p>
</blockquote>
<h3 id="静态链表的删除操作"><a href="#静态链表的删除操作" class="headerlink" title="静态链表的删除操作"></a>静态链表的删除操作</h3><h3 id="静态链表优缺点"><a href="#静态链表优缺点" class="headerlink" title="静态链表优缺点"></a>静态链表优缺点</h3><p>总结一下静态链表的优缺点</p>
<p>优点：</p>
<ul>
<li>在插入和删除操作时，只需要修改游标，不需要移动元素，从而改进了顺序存储结构中的插入和删除操作需要移动大量元素的缺点。</li>
</ul>
<p>缺点：</p>
<ul>
<li>没有解决连续存储分配带来的表长难以确定的问题</li>
<li>失去了顺序存储结构随机存取的特性</li>
</ul>
<p>总的来说，静态链表其实是为了给没有指针的高级语言设计的一种实现单链表能力的方法。尽管大家不一定会用得上，但这样的思考方式是非常巧妙的，应该理解其思想，以备不时之需。</p>
<h3 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h3><blockquote>
<p>将单链表中终端结点的指针端由空指针改为指向头结点，就使整个单链表形成一个环，这种头尾相接的单链表称为单循环链表，简称<strong>循环链表</strong> (circular linked list) 。</p>
<p>为了使空链表与非空链表处理一致，我们通常设一个头结点，当然 ，这并不是说，循环链表一定要头结点，这需要注意。循环链表带有头结点的空链表如图 3-13-3 所示 :</p>
</blockquote>
<p><img src="http://p05qxk5gj.bkt.clouddn.com/1511924236%281%29.jpg" alt=""></p>
<blockquote>
<p>对于非空的循环链表就如图 3-13-4 所示。</p>
</blockquote>
<p><img src="http://p05qxk5gj.bkt.clouddn.com/1511924240%281%29.jpg" alt=""></p>
<blockquote>
<p>其实循环链表和单链表的主要差异就在于循环的判断条件土，原来是判断 p-&gt;next 是否为空，现在则是 p -&gt; next 不等于头结点，则循环未结束。<br>在单链表中，我们有了头结点时，我们可以用 0(1)的时间访问第一个结点，但对于要访问到最后一个结点，却需要 O(n)时间，因为我们需要将单链表全部扫描一遍。<br>有没有可能用 0(1)的时间由链表指针访问到最后一个结点呢?当然可以。<br>不过我们需要改造一下这个循环链表，不用头指针，而是用指向终端结点的尾指针来表示循环链表(如图 3.13.5 所示) ，此时查找开始结点和终端结点都很方便了。<br><img src="http://p05qxk5gj.bkt.clouddn.com/1511924246%281%29.jpg" alt=""></p>
<p>从上图中可以看到，终端结点用尾指针 rear 指示，则查找终端结点是 0(1) ，而开始结点，其实就是 rear-&gt;next-&gt;next，其时间复杂也为 0(1)。</p>
<p>举个程序的例子，要将两个循环链袭合并成一个表时，有了尾指针就非常简单了。 比如下面的这两个循环链衰，它们的尾指针分别是 rearA 和 rearB，如图 3-13-6 所示。</p>
</blockquote>
<p><img src="http://p05qxk5gj.bkt.clouddn.com/1511924253%281%29.jpg" alt=""><br><img src="http://p05qxk5gj.bkt.clouddn.com/1511924269%281%29.jpg" alt=""></p>
<h3 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h3><blockquote>
<p>双向链表 (也uble linked List) <strong>是在单链表的每个结点中，再设置一个指向其前驱结点的指针域。</strong>所以在双向链表中的结点都有两个指针域， 一个指向直接后继，另一个指向直接前驱。</p>
<p>既然单链表也可以有循环链衰，那么双向链表当然也可以是循环衰。<br>双向链表的循环带头结点的空链表如图3-14-3 所示。 </p>
</blockquote>
<p><img src="http://p05qxk5gj.bkt.clouddn.com/1511924282%281%29.jpg" alt=""></p>
<blockquote>
<p>由于这是双向链表，那么对于链表中的某一个结点 p，它的后继的前驱是谁?当然还是它自己。它的前驱的后继自然也是它自己，即:<br>p-&gt;next-&gt;prior = p = p-&gt;prior-&gt;next </p>
<p>插入操作时，其实并不复杂，不过顺序很重要，千万不能写反了。<br>我们现在假设存储元素 e 的结点为:S，要实现将结点 s 插入到结点 p 和 p -&gt; next 之间需要下面几步，如图 3-14-5 所示。</p>
</blockquote>
<p><img src="http://p05qxk5gj.bkt.clouddn.com/1511924300%281%29.jpg" alt=""></p>
<blockquote>
<p>关键在于它们的顺序，由于第 2 步和第 3 步都用到了 p-&gt;next。如果第 4 步先执行，则会使得p-&gt;next 提前变成了 S，使得插入的工作完不成。 所以我们不妨把上面这张图在理解的基础上记忆，顺序是先搞定 s 的前驱和后继，再搞定后结点的前驱，最 后解决前结点的后继。<br>如果插入操作理解了，那么删除操作，就比较简单了。<br>若要删除结点 p，只需要下面两步骤，如图 3-14-6 所示。</p>
</blockquote>
<p><img src="http://p05qxk5gj.bkt.clouddn.com/1511924893%281%29.jpg" alt=""></p>
<blockquote>
<p>线性表的这两种结构</p>
</blockquote>
<p><img src="http://p05qxk5gj.bkt.clouddn.com/1511924964%281%29.jpg" alt=""></p>
]]></content>
      
        <categories>
            
            <category> 数据结构与算法呀~ </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[数据结构的基本概念和术语]]></title>
      <url>/data-structure/</url>
      <content type="html"><![CDATA[<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><blockquote>
<p>是相互之间存在一种或多种特定关系的数据元素的集合</p>
</blockquote>
<a id="more"></a>
<h2 id="什么是数据结构"><a href="#什么是数据结构" class="headerlink" title="什么是数据结构"></a>什么是数据结构</h2><blockquote>
<p>数据结构是一门研究非数值计算的程序设计问题中的操作对象，以及官们之间的关系和操作等相关 问题的学科。</p>
</blockquote>
<h2 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h2><blockquote>
<p>数据:是描述客观事物的符号，是计算机中可以操作的对象，是能被计算机识 别，并输入给计算机处理的符号集合。</p>
</blockquote>
<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><blockquote>
<p>简单的理解就是关系。严格点说， 结构是指各个组成部分相互搭配和排列的方式。</p>
</blockquote>
<h2 id="逻辑结构与物理结构"><a href="#逻辑结构与物理结构" class="headerlink" title="逻辑结构与物理结构"></a>逻辑结构与物理结构</h2><blockquote>
<p>按照视点的不同， 我们把数据结构分为<strong>逻辑结构</strong>和<strong>物理结构</strong>。</p>
</blockquote>
<h3 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h3><blockquote>
<p>逻辑结构：是指数据对象中数据元素之间的相互关系。</p>
</blockquote>
<h3 id="逻辑结构分为下列四种："><a href="#逻辑结构分为下列四种：" class="headerlink" title="逻辑结构分为下列四种："></a>逻辑结构分为下列四种：</h3><h3 id="集合结构"><a href="#集合结构" class="headerlink" title="集合结构"></a>集合结构</h3><pre><code> 集合结构：集合结构中的数据元素除了同属于一个集合外，它们之间没有其他关系。
 各个数据元素是&quot;平等&apos;的，它们的共同属性是&quot;同属于一个集合&quot;。数据结构中 的集合关系就类似于数学中的集合
（如下图所示）
</code></pre><p><img src="https://i.imgur.com/oC6pd9i.png" alt=""></p>
<h3 id="线性结构"><a href="#线性结构" class="headerlink" title="线性结构"></a>线性结构</h3><blockquote>
<p>2.线性结构：线性结构中的数据元素之间是一对一的关系<br>        （如下图所示）</p>
</blockquote>
<p><img src="https://i.imgur.com/XXQFnv5.png" alt=""></p>
<h3 id="树形结构"><a href="#树形结构" class="headerlink" title="树形结构"></a>树形结构</h3><blockquote>
<p>3.树形结构:树形结构中的数据元素之间存在一种一对多的层次关系<br>        （如下图所示）</p>
</blockquote>
<p><img src="https://i.imgur.com/gdISiB3.png" alt=""></p>
<h3 id="图形结构"><a href="#图形结构" class="headerlink" title="图形结构"></a>图形结构</h3><blockquote>
<p>4.图形结构:图形结构的数据元素是多对多的关系<br>    (如下图所示)</p>
</blockquote>
<p><img src="https://i.imgur.com/dRXgOvP.png" alt=""></p>
<blockquote>
<p>我们在用示意图表示数据的逻辑结构时，要注意两点:</p>
</blockquote>
<ul>
<li>将每一个数据元素看做一个结点，用圈圈表示。</li>
<li>元素之闯的逻辑关系用结点之间的连线表示.如果这个关系是有方向的，那么用带箭头的连续表示。</li>
</ul>
<h2 id="物理结构"><a href="#物理结构" class="headerlink" title="物理结构"></a>物理结构</h2><p>物理结构 (很多书中也叫做存储结构，只要在理解上把它们当一回事就可以了)。</p>
<p>物理结构：是指数据的逻辑结构在计算机中的存储形式</p>
<p>数据是数据元素的集合，那么根据物理结构的定义，实际上就是如何把数据元素 存储到计算机的存储器中。存储器主要是针对内存而言的，像硬盘、软盘、光盘等外 部存俯器的数据组织通常用文件结构来描述。</p>
<p>数据的存储结构应正确反映数据元素之间的逻辑关系，这才是最为关键的，如何 存储数据元素之间的逻辑关系，是实现物理结构的重点和难点。</p>
<p>数据元素的存储结构形式有两种:<strong>顺序存储</strong>和<strong>链式存储</strong>。</p>
<h3 id="顺序存储结构"><a href="#顺序存储结构" class="headerlink" title="顺序存储结构"></a>顺序存储结构</h3><blockquote>
<p>顺序存储结构:是把数据元素存放在地址连续的存储单元里，其数据间的逻辑关系和物理关系是一致的</p>
</blockquote>
<p><img src="https://i.imgur.com/vxIIFNF.png" alt=""></p>
<h3 id="链式存储结构"><a href="#链式存储结构" class="headerlink" title="链式存储结构"></a>链式存储结构</h3><blockquote>
<p>链式存储结构：是把数据元素存放在任意的存储单元里，这组存储单元可以是连续的，也可以是不连续的。<br>                数据元素的存储关系并不能反映其逻辑关系，因此需要一个指针存放数据元素的地址，这样通过地址就可以找到相关联数据元素的位置<br>                （如下图所示）</p>
</blockquote>
<p><img src="https://i.imgur.com/BGtDVE8.png" alt=""></p>
<blockquote>
<p>显然，链式存储就灵活多了，数据存在哪里不重要，只要有一个指针存放了相应 的地址就能找到白了。</p>
<p>逻辑结构是面向问题的，而物理结构就是面向计算机的，其基本的目标就是将数 据及其逻辑关系存储到计算机的内存中。</p>
</blockquote>
<h1 id="抽象数据类型"><a href="#抽象数据类型" class="headerlink" title="抽象数据类型"></a>抽象数据类型</h1><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><blockquote>
<p>数据类型:是指一组性质相同的值的集合及定义在此集合上的一些操作的总称。</p>
</blockquote>
<p>数据类型是按照值的不同进行划分的。在高级语言中，每个变盘、常量和表达式 都有各自的取值范围。类型就用来说明变量或表达式的取值范围和所能进行的操作。</p>
<p><strong>抽象是指抽取出事物具有的普遍性的本质</strong>。它是抽出问题的特征而忽略非本质的细节，是对具体事物的一个概括。抽象是一种思考问题的方式，它隐藏了繁杂的细节，只保留实现目标所必需的信息。</p>
<h2 id="抽象数据类型-1"><a href="#抽象数据类型-1" class="headerlink" title="抽象数据类型"></a>抽象数据类型</h2><p>我们对已有的数据类型进行抽象，就有了抽象数据类型。</p>
<p><strong>抽象数据类型 (Abstract Dataη肘， ADT)</strong> : <strong>是指一个数学模型及定义在该模型上的一组操作</strong>。抽象数据类型的定义仅取决于它的一组逻辑特性，而与其在计算机内部如何表示和实现无关。</p>
<p><strong>“抽象”的 意义在于数据类型的数学抽象特性</strong>。</p>
<p>抽象数据类型体现了程序设计中问题分解、抽象和信息隐藏的特性。抽象数据类型把实际生活中的问题分解为多个规模小且窑易处理的问题， 然后建立一个计算机能处理的数据模型，并把每个功能模块的实现细节作为一个独立的单元，从而使具体实现过程隐藏起来。</p>
<p>为了便于在之后的讲解中对抽象数据类型进行规范的描述，我仍给出了描述抽象 数据类型的标准格式:</p>
<pre><code>ADT 抽象数据类型名
Data 
    数据元素之间逗得关系的定义
Operation 
    操作 1
        初始条件
        操作结来描述
    操作 2
        ....
    操作 n
        ....
endADT
</code></pre>]]></content>
      
        <categories>
            
            <category> 数据结构与算法呀~ </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[算法]]></title>
      <url>/algorithm/</url>
      <content type="html"><![CDATA[<h2 id="算法的定义"><a href="#算法的定义" class="headerlink" title="算法的定义"></a>算法的定义</h2><blockquote>
<p>算法是解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作</p>
</blockquote>
<a id="more"></a>
<blockquote>
<p>算法定义中，提到了指令，指令能被人或机器等计算装置执行。它可以是计算机 指令，也可以是我们平时的语言文字。</p>
<p>为了解决某个或某类问题，需要把指令表示成一定的操作序列，操作序列包括一 组操作，每一个操作都完成特定的功能，这就是算法了。</p>
</blockquote>
<h2 id="算法的特征"><a href="#算法的特征" class="headerlink" title="算法的特征"></a>算法的特征</h2><blockquote>
<p>算法具有五个基本特性：输入、输出、有穷性、确定性和可行性。</p>
</blockquote>
<h3 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h3><blockquote>
<p>输入和输出特性比较容易理解， 算法具有零个或多个输入。尽管对于绝大多数算 法来说，输入参数都是必要的，但对于个别情况，如打印 “hello world! “ 这样的代 码，不需要任何输入参数3 因此算法的输入可以是零个。 算法至少有一个或多个输 出， 算法是一定需要输出的，不需要输出，你用这个算法干吗?输出的形式可以是打 印输出，也可以是返回一个或多个值等.</p>
</blockquote>
<h3 id="有穷性"><a href="#有穷性" class="headerlink" title="有穷性"></a>有穷性</h3><blockquote>
<p>有穷性:指算法在执行有限的步骤之后，自动结束而不会出现无限循环，并且每 一个步骤在可接受的时间内完成。现实中经常会写出死循环的代码，这就是不满足有穷性。当然这里有穷的概念并不是纯数学意义的，而是在实际应用当中合理的、可以接受的”有边界飞你说你写一个算法，计算机需要算上个二十年，一定会结束，它在数学意义上是有穷了，可是媳妇都熬成婆了，算法的意义也不就大了。</p>
</blockquote>
<h3 id="确定性"><a href="#确定性" class="headerlink" title="确定性"></a>确定性</h3><blockquote>
<p>确定性:算法的每一步骤都具有确定的含义， 不会出现二义性。 算法在一定条件下，只有一条执行路径，相同的输入只能有唯一的输出结果。算法的每个步骤被精确定义而无歧义。</p>
</blockquote>
<h3 id="可行性"><a href="#可行性" class="headerlink" title="可行性"></a>可行性</h3><blockquote>
<p>可行性:算法的每一步都必须是可行的， 也就是说，每一步都能够通过执行有限次数完成。 可行性意味着算法可以转换为程序上机运行，并得到正确的结果。尽管在目前计算机界也存在那种没有实现的极为复杂的算法， 不是说理论上不能实现， 而是因为过于复杂，我们当前的编码方法、工具和大脑限制了这个工作，不过这都是理论研究领域的问题，不属于我们现在要考虑的范围。</p>
</blockquote>
<h2 id="算法设计的要求"><a href="#算法设计的要求" class="headerlink" title="算法设计的要求"></a>算法设计的要求</h2><h3 id="1-正确性"><a href="#1-正确性" class="headerlink" title="1.正确性"></a>1.正确性</h3><blockquote>
<p>正确性:算法的正确性是指算法至少应该具有输入、输出和加工处理无歧义性、 能正确反映问题的需求、能够得到问题的正确答案。</p>
<p>但是算陆的”正确”通常在用法上有很大的差别，大体分为以下四个层次。</p>
<ol>
<li>算法程序没有语法错误。</li>
<li>算法程序对于合法的输入数据能够产生满足要求的输出结果。</li>
<li>算法程序对于非法的输入数据能够得出满足规格说明的结果。</li>
<li>算法程序对于精心选择的，甚至刁难的测试数据都有满足要求的输出结果。</li>
</ol>
<p>对于这四层含义，层次 1 要求最低，但是仅仅没有语法错误实在谈环上是好算 法。 这就如同仅仅解决温饱， 不能算是生活幸福一样。 而层次 4 是最困难的，我们几 乎不可能逐一验证所有的输入都得到正确的结果。</p>
<p>因此算法的正确性在大部分情况下都不可能用程序来证明，而是用数学方法证明 的。证明一个复杂算法在所4寄层次上都是正确的，代价非常昂贵。所以一般情况下， 我们把层次 3 作为一个算法是否正确的标准。<br>好算法还有一个特征：容易理解</p>
</blockquote>
<h3 id="2-可读性"><a href="#2-可读性" class="headerlink" title="2.可读性"></a>2.可读性</h3><blockquote>
<p>可读性: 算法设计的另一目的是为了便于阅读、 理解和交流。</p>
</blockquote>
<h3 id="3-健壮性"><a href="#3-健壮性" class="headerlink" title="3.健壮性"></a>3.健壮性</h3><blockquote>
<p>健壮性:当输入数据不合法时，算法也能做出相关处理， 而不是产生异常或莫名 其妙的结果。</p>
</blockquote>
<h3 id="4-时间效率高和存储量低"><a href="#4-时间效率高和存储量低" class="headerlink" title="4.时间效率高和存储量低"></a>4.时间效率高和存储量低</h3><blockquote>
<p>好的算法还应该具备时间效率高和存储虽低的特点。</p>
<p>时间效率指的是算法的执行时间 ，对于同一个问题，如果有多个算法能够解决，执行时间短的算法效率高，执行时间长的效率低。存储量需求指的是算法在执行过程中需要的最大存储空间，主要指算法程序运行时所占用的内存或外部硬盘存储空间。设计算法应该尽量满足时间效率高和存储量低的需求。</p>
<p>在生活中，人们都希望花最少 的钱，用最短的时间 ，办最大的事，算法也是一样的思想，最好用最少的存储空间，花最少的时间，办成同样的事就是好的算法。求 100 个人的高考成绩平均分 ，与求全省的所有考生的成绩平均分在占用时间和内存存储上是有非常大的差异的 ，我们自然是追求可以高效率和低存储量的算法来解决问题。</p>
<p>综上，好的算法，应该具有正确性、 可读性、健壮性、 高效率和低存储量的特征。</p>
</blockquote>
<h2 id="算法效率的度量方法"><a href="#算法效率的度量方法" class="headerlink" title="算法效率的度量方法"></a>算法效率的度量方法</h2><h3 id="事后统计方法"><a href="#事后统计方法" class="headerlink" title="事后统计方法"></a>事后统计方法</h3><p>事后统计方法:这种方法主要是通过设计好的测试程序和数据，利用计算机计时 器对不同算法编制的程序的运行时间进行比较，从而确定算法效率的高低。</p>
<p>但这种方法显然是有很大缺陷的:</p>
<blockquote>
<ul>
<li><p>必须依据算法事先编制好程序，这通常需要花费大量的时间和精力。 如果 编制出来发现宫根本是很糟糕的算法，不是竹篮打水一场空吗?</p>
</li>
<li><p>时间的比较依赖计算机硬件和软件等环境因素，有时会掩盖算法本身的优 劣。 要知道，现在的一台四核处理器的计算机， N~当年 286、 386、 486 等 老爷爷辈的机器相比，在处理算法的运算速度上，是不能相提并论的 i 而 所用的操作系统、编译器、 运行框架等软件的不同，也可以影响官们的结 果;就算是同一台机器， CPU 使用率和内存占用情况不一样，也会造成细 微的差异。</p>
</li>
<li><p>算法的测试数据设计困难，并且程序的运行时间往往还与测试数据的规模 有很大关系，效率高的算法在才、的测试数据面前往往得不到体现。 比如 10 个数字的排序，不管用什么算沽， 差异几乎是零。 而如果有一百万个随机 数字排序，那不同算法的差异就非常大了。那么我们为了比较算沽，到底 用多少数据来测试，这是很难判断的问题。</p>
</li>
</ul>
<p>基于事后统计方法有这样那样的缺陷，我们考虑不予采纳。</p>
</blockquote>
<h3 id="事前分析估算方法"><a href="#事前分析估算方法" class="headerlink" title="事前分析估算方法"></a>事前分析估算方法</h3><blockquote>
<p>我们的计算机前辈们，为了对算法的评判更科学，研究出了一种叫做事前分析估算的方法。</p>
</blockquote>
<p><strong>事前分析估算方法:在计算机程序编制前，依据统计方法对算法进行估算。</strong></p>
<blockquote>
<p>经过分析，我们发现，一个用高级程序语言编写的程序在计算机上运行时所消耗的时间取决于下列因素:</p>
<ol>
<li>算法采用的策略、方法。</li>
<li>编译产生的代码质量。</li>
<li>问题的输入规模。</li>
<li>机器执行指令的速度。<br>第 1 条当然是算法好坏的根本，第 2 条要由软件来支持， 第 4 条要看硬件性能。 也就是说， 抛开这些与计算机硬件、软件有关的因素，<strong>一个程序的运行时间，依赖于算法的好坏和问题的输入规模</strong>。 所谓<strong>问题输入规模是指输入量的多少</strong>。</li>
</ol>
</blockquote>
<p>我们在分析一个算法的运行时间时，重要的是把基本操作的敬量与输入规模关联 起来， f!P基本操作的数量必须表示成输入规模的函数。如下图所示<br><img src="https://i.imgur.com/nNtYjhH.png" alt=""><br>我们可以这样认为，随着 n 值的越来越大，它们在时间效率上的差异也就越来越大。好比你们当中有些人每天都在学习，我指有用的学习，而不是只为考试的死读书， 每天都在进步，而另一些人，打打游戏，睡睡大觉。 人校时大家都一样， 但毕业时结果可能就大不一样，前者名企争抢着耍，后者求职无门。</p>
<h3 id="函数的渐近增长"><a href="#函数的渐近增长" class="headerlink" title="函数的渐近增长"></a>函数的渐近增长</h3><blockquote>
<p>函数的渐近增长:给定两个函数 f ( n )和 g ( n )， 如果存在一个整数 N， 使得对于所有的 n &gt; N, f ( n )总是比 g ( n )大，那么， 我们说 f ( n ) 的增长渐近快于 g ( n )。</p>
<p>与最高次项相乘的常数并不重要。</p>
<p>最高次项的指数大 的，函数随着 n 的增长，结果也会变得增长特别快。</p>
<p><strong>判断一个算法的效率时，函数中的常数和其他次要项常常可以忽略，而更应该关注主项(最高阶项) 的阶数。</strong></p>
<p>判断一个算法好不好，我们只通过少量的数据是不能做出准确判断的。根据刚才 的几个样例 ， 我们发现，如果我们可以对比这几个算法的关键执行次数函数的渐近增 长性，基本就可以分析出:<strong>某个算法，随着 n 的增大，它会越来越优于另一算法，或 者越来越差于另一算法。</strong>这其实就是事前估算方法的理论依据， 通过算法时间复杂度来估算算法时间效率。</p>
</blockquote>
<h3 id="算法时间复杂度"><a href="#算法时间复杂度" class="headerlink" title="算法时间复杂度"></a>算法时间复杂度</h3><h4 id="算法时间复杂度定义"><a href="#算法时间复杂度定义" class="headerlink" title="算法时间复杂度定义"></a>算法时间复杂度定义</h4><blockquote>
<p><strong>在进行算法分析时， 语旬总的执行次数 T ( n )是关于问题规模 n 的函数，进而分析 T ( n )随 n 的变化情况并确定T ( n ) 的数量级。算法的时间复杂度，也就是算法的时间量度，记作：T ( n ) = O ( f ( n ) )。它表示随问题规模n的增大，算法执行时间的增长率和f ( n ) 的增长率相同。称作算法的渐远时间复杂度，简称胃时间复杂度。f ( n ) 是问题规模n的某个函数。</strong></p>
<p>这样用大写 O()来体现算法时间复杂度的记法，我们称之为大 0 记法。<br>一般情况下，随着 n 的增大， T(n)增长最慢的算法为最优算法。</p>
<p>显然，由此算法时间复杂度的定义可知，我们的三个求和算法的时间复杂度分别 为 O(n) ， O(1)， O(n²)。我们分别给官们取了非官方的名称， 0(1)叫常数阶、 O(n)叫线 性阶、 O(n²)叫平方阶，当然，还有其他的一些阶，我们之后会介绍。</p>
</blockquote>
<h4 id="推导大-O-阶方法"><a href="#推导大-O-阶方法" class="headerlink" title="推导大 O 阶方法"></a>推导大 O 阶方法</h4><blockquote>
<p>如何分析一个算法的时间复杂度呢?即如何推导大 0 阶呢?</p>
<h5 id="推导大-O-阶"><a href="#推导大-O-阶" class="headerlink" title="推导大 O 阶:"></a>推导大 O 阶:</h5><ol>
<li>用常鼓 1 取代运行时闺中的所有加法常颤。</li>
<li>在修改后的运行次搬画锺中，只保留最高阶项。</li>
<li>如果最高阶项存在且不是 1 ，则去除与这个项相乘的常敢。<br>得到的结果就是大 O 阶。<h4 id="常数阶"><a href="#常数阶" class="headerlink" title="常数阶"></a>常数阶</h4>首先顺序结构的时间复杂度。下面这个算法，也就是刚才的第二种算法(高斯算法) .为什么时间复杂度不是 O(3) .而是O(1)。</li>
</ol>
</blockquote>
<pre><code>ìnt sum = O, n =100;    /*执行一次 */ 
sum = (1+n)*n/2;        /*执行一次 */
prìntf ( &quot;%d&quot; , sum) ; /*执行一次 */
</code></pre><blockquote>
<p>这个算法的运行次数函数是 f (n) =3。 根据我们推导大 0 阶的方法，第一步就是 把常数项 3 改为 1。在保留最高阶项时发现，它根本没有最高阶项，所以这个算法的时间复杂度为 0(1)。</p>
<p>另外，我们试想一下，如果这个算法当中的语句 sum= ( 1+0) 句12 有 10 旬，<br>即:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int sum = 0, 0 = 100; / *执行 1 次*/ </span><br><span class="line">sum = (1+n)*0/2; /*执行第 1 次*/ </span><br><span class="line">sum = (1+n)*0/2; /*执行第 2 次*/</span><br><span class="line">sum = (1+n)*0/2; /*执行第 3 次*/</span><br><span class="line">sum = (1+n)*0/2; /*执行第 4 次*/</span><br><span class="line">sum = (1+n)*0/2; /*执行第 5 次*/</span><br><span class="line">sum = (1+n)*0/2; /*执行第 6 次*/</span><br><span class="line">sum = (1+n)*0/2; /*执行第 7 次*/</span><br><span class="line">sum = (1+n)*0/2; /*执行第 8 次*/</span><br><span class="line">sum = (1+n)*0/2; /*执行第 9 次*/</span><br><span class="line">sum = (1+n)*0/2; /*执行第 10 次*/</span><br><span class="line">printf (&quot;%d&quot;,sum); /*执行 1 次*/</span><br></pre></td></tr></table></figure>
<blockquote>
<p>事实上无论 n 为多少，上面的两段代码就是 3 次和 12 次执行的差异。这种与问 题的大小无关 (n 的多少) ，执行时间恒定的算法，我们称之为具有 0(1)的时间复杂 度，又叫常数阶。</p>
<p>注意: 不管这个常数是多少，我们都记作 O(1)，而不能是 0(3)、 0(12)等其他任何数字，这是初学者常常犯的错误。<br>对于分支结构而言，无论是真，还是假，执行的次数都是恒定的，不会随着 n 的 变大而发生变化，所以单纯的分支结构(不包含在循环结构中) ，其时间复杂度也是0(1)。</p>
</blockquote>
<h4 id="线性阶"><a href="#线性阶" class="headerlink" title="线性阶"></a>线性阶</h4><blockquote>
<p>线性阶的循环结构会复杂很多。要确定某个算法的阶次，我们常常需要确定某个 特定语句或某个语句集运行的次数。因此，我们要分析算法的复杂度，关键就是要分 析循环结构的运行情况。</p>
<p>下面这段代码，它的循环的时间复杂度为 O(n) ， 因为循环体中的代码须要执行 n次。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int i; </span><br><span class="line">for (i = 0; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">	/* 时间复杂度为O(1)的程序步骤序列 */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="对数阶"><a href="#对数阶" class="headerlink" title="对数阶"></a>对数阶</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int count = 1; </span><br><span class="line">while (count &lt; n)</span><br><span class="line">&#123;</span><br><span class="line">	count = count * 2; </span><br><span class="line">	/* 时间复杂皮为 O(1） 的程序步骤序列 */ </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>由于每次 count 乘以 2 之后，就距离 n 更近了一分。 也就是说，有多少个2相乘后大于 n ，则会退出循环。 由 2x=n 得到 x=log2n。 所以这个循环的时间复杂度为 o (logn)。</p>
</blockquote>
<h4 id="平方阶"><a href="#平方阶" class="headerlink" title="平方阶"></a>平方阶</h4><p>下面例子是一个循环嵌套，它的内循环刚才我们已经分析过，时间复杂度为 O(n)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">i nt i ,j ; </span><br><span class="line">for (i = 0; i &lt; n; i++) </span><br><span class="line">&#123;</span><br><span class="line">		for ( j = 0 ; j &lt; n ; j++)</span><br><span class="line">	&#123; </span><br><span class="line">		/*时间复杂度为O(1)的程序步骤序列*/</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>而对于外层的循环，不过是内部这个时间复杂度为 O(n)的语旬，再循环 n 次。 所 以这段代码的时间复杂度为 O(n²).<br>如果外循环的循环次数改为了m ，时间复杂度就变为 O(mXn)。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">i nt i ,j ; </span><br><span class="line">for (i = 0; i &lt; m; i++) </span><br><span class="line">&#123;</span><br><span class="line">		for ( j = 0 ; j &lt; n ; j++)</span><br><span class="line">	&#123; </span><br><span class="line">		/*时间复杂度为O(1)的程序步骤序列*/</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>所以我们可以总结得出，循环的时间复杂度等于循环体的复杂度乘以该循环运行的次数。</p>
<p>那么下面这个循环嵌套，它的时间复杂度是多少呢?</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">i nt i ,j ; </span><br><span class="line">for (i = 0; i &lt; m; i++) </span><br><span class="line">&#123;</span><br><span class="line">		for ( j = 0 ; j &lt; n ; j++)</span><br><span class="line">	&#123; </span><br><span class="line">		/*时间复杂度为O(1)的程序步骤序列*/</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>由于当 i= 0 时，内循环执行了 n 次，当 i = 1 时，执行了 n-1 次，……当 i=n一1 时，执行了 1 次。所以总的执行次数为:<br><img src="https://i.imgur.com/Iag37rb.png" alt=""></p>
<p>用我们推导大 0 阶的方法，第一条，没有加法常数不予考虑j 第二条，只保留最 高阶项，因此保留时/2; 第三条，去除这个项相乘的常数，也就是去除 1/2 ，最终这 段代码的时间复杂度为 O(n2)。</p>
</blockquote>
<h3 id="常见的时间复杂度"><a href="#常见的时间复杂度" class="headerlink" title="常见的时间复杂度"></a>常见的时间复杂度</h3><blockquote>
<p>常见的时问复杂度如表所示<br><img src="https://i.imgur.com/Ux7JQB0.png" alt=""></p>
<p>常用的时间复杂度所耗费的时间从小到大依次是:</p>
</blockquote>
<p><img src="https://i.imgur.com/qx6SKEj.png" alt=""></p>
<p><img src="https://i.imgur.com/Or9JXvp.png" alt=""></p>
<h3 id="最坏情况与平均情况"><a href="#最坏情况与平均情况" class="headerlink" title="最坏情况与平均情况"></a>最坏情况与平均情况</h3><blockquote>
<p>我们查找一个有n 个随机数字数组中的某个数字， 最好的情况是第一个数字就是，那么算法的时间复杂度为 0(1) ，但也有可能这个数字就在最后一个位置上待着，那么算法的时间复杂度就是 O(n)，这是最坏的一种情况了。</p>
<p><strong>最坏情况运行时间是一种保证，那就是运行时间将不会再坏了。 在应用中，这是 一种最重要的需求， 通常， 除非特别指定， 我们提到的运行时间都是最坏情况的运行 时间。</strong></p>
<p>而平均运行时间也就是从概率的角度看 ， 这个数字在每一个位置的可能性是相同的，所以平均的查找时间为n/2 次后发现这个目标元素。<br><strong>平均运行时闯是所有情况中最有意义的，因为它是期望的运行时间。</strong>也就是说， 我们运行一段程序代码时，是希望看到平均运行时间的。可现实中 ，平均运行时间很难通过分析得到，一般都是通过运行一定数量的实验数据后估算出来的。<br>对算法的分析，一种方法是计算所有情况的平均值，这种时间复杂度的计算方法称为平均时间复杂度。 另一种方法是计算最坏情况下的时间复杂度，这种方法称为最坏时间复杂度。 一般在没有特殊说明的情况下，都是指最坏时间复杂度。</p>
</blockquote>
<h3 id="算法空间复杂度"><a href="#算法空间复杂度" class="headerlink" title="算法空间复杂度"></a>算法空间复杂度</h3><blockquote>
<p>算法的空间复杂度通过计算算法所需的存储空间实现，算法空间复杂度的计算公式记作: S(n)= O(f(n))，其中， n 为问题的规模， f(n)为语句关于 n 所占存储空间的函数。</p>
<p>一般情况下， 一个程序在机器上执行时，除了需要存储程序本身的指令、常数、 变量和输入数据外，还需要存储对数据操作的存储单元，若输入数据所占空间只取决 于问题本身，和算法无关，这样只需要分析该算法在实现时所需的辅助单元即可。若 算法执行时所帘的辅助空间相对于输入数据量而言是个常数，则称此算法为原地工 作，空间复杂度为 0(1)。</p>
<p>通常， 我们都使用”时间复杂度”来指运行时间的需求，使用”空间复杂度”指 空间需求。当不用限定词地使用”复杂度’时，通常都是指时间复杂度。显然我们这 本书重点要讲的还是算法的时间复杂度的问题。</p>
</blockquote>
<h2 id="总结回顾"><a href="#总结回顾" class="headerlink" title="总结回顾"></a>总结回顾</h2><blockquote>
<ul>
<li>算法的定义:算法是解决特定问题求解步骤的描述，在计算机中为指令的有限序 列，并且每条指令表示一个或多个操作。</li>
<li>算法的特性: 有穷性、确定性、可行性、输入、输出。</li>
<li>算法的设计的要求: 正确性、可读性、健壮性、 高效率和低存储量需求。</li>
<li>算法特性与算法设计容易混，需要对比记忆。</li>
<li>算法的度量方法: 事后统计方法(不科学、不准确)、 事前分析估算方法。</li>
</ul>
<p>在讲解如何用事前分析估算方法之前，我们先给出了函数潮近增长的定义。</p>
<p>函数的渐近增长:给定两个函数 f(n)和 g(n)，如果存在一个整数 N， 使得对于所有的 n &gt; N，f(n)总是比 g(n)大，那么，我们说 f(n)的增长渐近快于g(n)。于是我们可以得出一个结论，判断一个算法好不好，我们只通过少量的数据是不能做出准确判断的 ，如果我们可以对比算法的关键执行次数函数的渐近增长性，基本就可以分析出 : 某个算法，随着 n 的变大，它会越来越优于另一算法，或者越来越羞于另一算法。</p>
<p>然后给出了算法时间复杂度的定义和推导大 0 阶的步骤。<br>推导大 0 阶:</p>
<ul>
<li>用常数 1 取代运行时间中的所有加法常数。</li>
<li>在修改后的运行次数函数中，只保留最高阶项。</li>
<li>如果最高阶项存在且不是 1 ，则去除与这个项相乘的常数。<br>得到的结果就是大 0 阶。</li>
</ul>
<p>通过这个步骤，我们可以在得到算法的运行次数表达式后，很快得到宫的时间复 杂度，即大 0 阶。同时我也提醒了大家，其实推导大 0 阶很容易，但如何得到运行次数的表达式却是需要数学功底的。</p>
</blockquote>
<p>接着我们给出了常见的时间复杂度所耗时阔的大小排列:<br><img src="https://i.imgur.com/nXKnAd6.png" alt=""></p>
<p>最后，我们给出了关于算法最坏情况和平均情况的概念，以及空间复杂度的概念。</p>
]]></content>
      
        <categories>
            
            <category> 数据结构与算法呀~ </category>
            
        </categories>
        
        
    </entry>
    
  
  
</search>
